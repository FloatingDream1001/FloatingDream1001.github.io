<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Stack入门</title>
    <url>/posts/ecb08547.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">Stack</span><br><span class="p center small">数据结构——栈的快速入门</span></p>
<h3 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h3><ol>
<li><p>栈是一个<code>先入后出</code>(FILO-First In Last Out)的有序列表。</p>
</li>
<li><p>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为<strong>栈顶</strong>(Top)，另一端为固定的一 端，称为<strong>栈底</strong>(Bottom)。</p>
</li>
<li><p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈项，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
</li>
<li>图解方式说明出栈（pop)和入栈(push) </li>
</ol>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230117181009950.png" alt="image-20230117181009950"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1) 子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。<br>2) 处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。<br>3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。<br>4) 二叉树的遍历。<br>5) 图形的深度优先(depth—first)搜索法。</p>
<h3 id="栈的代码实现"><a href="#栈的代码实现" class="headerlink" title="栈的代码实现"></a>栈的代码实现</h3><h4 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h4><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230117181553142.png" alt="image-20230117181553142"></p>
<ol>
<li><p>使用数组模拟栈</p>
</li>
<li><p>定义一个变量为top来表示栈顶，初始化为-1</p>
</li>
<li><p>入栈的操作，当有数据加入到栈时，top++，stack[top]=data;</p>
</li>
<li><p>出栈的操作，int value=stack[top];  top—;  return value;</p>
</li>
</ol>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个ArrayStack表示栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;  <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">//  用数组模拟栈，数据就放到该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span> <span class="params">( <span class="type">int</span> maxSize )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="built_in">this</span>.maxSize ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈——push</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span> <span class="params">( <span class="type">int</span> value )</span> &#123;</span><br><span class="line">        <span class="comment">//先判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span> ( isFull ( ) ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;栈满&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[ top ] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈——pop,将栈顶数据返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">pop</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( isEmpty ( ) ) &#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span> ( <span class="string">&quot;栈空，没有数据&quot;</span> );   <span class="comment">//运行异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[ top ];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈,遍历时从栈顶到栈底</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( isEmpty ( ) ) &#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;栈空没有数据~&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top ; i &gt;= <span class="number">0</span> ; i-- ) &#123;</span><br><span class="line">            System.out.printf ( <span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//测试一下ArrayStack是否正确</span></span><br><span class="line">        <span class="comment">//先创建一个ArrayStack</span></span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span> ( <span class="number">4</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;    <span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> ( System.in );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;show,表示显示菜单&quot;</span> );</span><br><span class="line">            System.out.println (<span class="string">&quot;exit,表示退出菜单&quot;</span> );</span><br><span class="line">            System.out.println (<span class="string">&quot;push,表示添加数据到菜单（入栈）&quot;</span> );</span><br><span class="line">            System.out.println (<span class="string">&quot;pop,表示从栈中取出数据（出栈）&quot;</span> );</span><br><span class="line">            System.out.println ( <span class="string">&quot;请输入你的选择&quot;</span> );</span><br><span class="line">            key = sc.next ( );</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    sc.close ();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println ( <span class="string">&quot;请输入一个数&quot;</span> );</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> sc.nextInt ( );</span><br><span class="line">                    stack.push ( value );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop ( );</span><br><span class="line">                        System.out.printf ( <span class="string">&quot;出栈的数据是%d\n&quot;</span>, res );</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println ( e.getMessage ());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">&quot;程序退出&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表模拟栈"><a href="#链表模拟栈" class="headerlink" title="链表模拟栈"></a>链表模拟栈</h4><ol>
<li><p>使用双链表</p>
</li>
<li><p>定义一个top表示栈顶，初始值为-1；</p>
</li>
<li><p>入栈的操作，当有数据加入到栈时，弄一个辅助节点，temp=top,temp.next指向新节点;heroNode.pre = temp;top=heroNode</p>
</li>
<li><p>出栈的操作。当出栈时，top的节点出去，辅助节点temp=top;temp.pre.next=null; top=temp.pre; temp.pre=null;</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个双向链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode3</span> <span class="variable">top</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">HeroNode3</span>(-<span class="number">1</span>,<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode3</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode3</span> ( <span class="number">0</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleLinkList</span> <span class="params">( <span class="type">int</span> maxSize )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top.no == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top.no == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双向链表</span></span><br><span class="line">    <span class="comment">//显示链表遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( isEmpty ()) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;栈空没有数据&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode3</span> <span class="variable">temp</span> <span class="operator">=</span> top;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> ( temp.no==-<span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println ( temp );</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp = temp.pre;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span> <span class="params">( String value )</span> &#123;</span><br><span class="line">        <span class="comment">//先判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span> ( isFull ( ) ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;栈满&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode3</span> <span class="variable">heroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode3</span> ( n++, value );</span><br><span class="line">        <span class="type">HeroNode3</span> <span class="variable">temp</span> <span class="operator">=</span> top;</span><br><span class="line"></span><br><span class="line">        temp.next    = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">        top=heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode3 <span class="title function_">pop</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( isEmpty ( ) ) &#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span> ( <span class="string">&quot;栈空，没有数据&quot;</span> );   <span class="comment">//运行异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">        HeroNode3 temp=top;</span><br><span class="line">        temp.pre.next=<span class="literal">null</span>;</span><br><span class="line">        top = temp.pre;</span><br><span class="line">        temp.pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个heroNode,每个HeroNode 对象是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String value;</span><br><span class="line">    <span class="keyword">public</span> HeroNode3 next;  <span class="comment">//指向后一个节点  默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode3 pre;  <span class="comment">//指向前一个节点   默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode3</span> <span class="params">( <span class="type">int</span> no, String value )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no       = no;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode3 [no=&quot;</span> + no + <span class="string">&quot;,value=&quot;</span> + value +  <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleListStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">DoubleLinkList</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkList</span> ( <span class="number">5</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;    <span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span> ( System.in );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;show,表示显示菜单&quot;</span> );</span><br><span class="line">            System.out.println (<span class="string">&quot;exit,表示退出菜单&quot;</span> );</span><br><span class="line">            System.out.println (<span class="string">&quot;push,表示添加数据到菜单（入栈）&quot;</span> );</span><br><span class="line">            System.out.println (<span class="string">&quot;pop,表示从栈中取出数据（出栈）&quot;</span> );</span><br><span class="line">            System.out.println ( <span class="string">&quot;请输入你的选择&quot;</span> );</span><br><span class="line">            key = sc.next ( );</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    sc.close ();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println ( <span class="string">&quot;请输入一个值&quot;</span> );</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> sc.next ( );</span><br><span class="line">                    stack.push ( value );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">HeroNode3</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop ( );</span><br><span class="line">                        System.out.printf ( <span class="string">&quot;出栈的数据是%s\n&quot;</span>, res.value );</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println ( e.getMessage ());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">&quot;程序退出&quot;</span> );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀、中缀、后缀表达式</title>
    <url>/posts/1c6d16c2.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">前缀、中缀、后缀表达式</span><br><span class="p center small">栈——初始前缀、中缀、后缀</span></p>
<h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><p><strong>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前</strong></p>
<p>举例说明，（3+4）*5-6的前缀表达式就是- x + 3 4 5 6</p>
<h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><p><strong>从右至左</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<h4 id="案例详解："><a href="#案例详解：" class="headerlink" title="案例详解："></a>案例详解：</h4><p><strong>例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:</strong></p>
<ol>
<li>从右至左扫描，将6、5、4、3压入堆栈</li>
<li>遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈</li>
<li>接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈</li>
<li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果（顶上-下一个）</li>
</ol>
<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><ol>
<li><p>中缀表达式就是常见的运算表达式，如(3+4)×5-6</p>
</li>
<li><p>中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，<strong>往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)</strong></p>
</li>
</ol>
<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><ol>
<li><p>后缀表达式又称<strong>逆波兰表达式,</strong>与前缀表达式相似，只是运算符位于操作数之后</p>
</li>
<li><p>举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –</p>
</li>
<li><p>在比如：</p>
<p>| 正常的表达式 | 逆波兰表达式  |<br>| —————— | ——————- |<br>| a+b          | a b +         |<br>| a+(b-c)      | a b c - +     |<br>| a+(b-c)<em>d    | a b c – d </em> + |<br>| a+d<em>(b-c)    | a d b c - </em> + |<br>| a=1+3        | a 1 3 + =     |</p>
</li>
</ol>
<h4 id="规则：-1"><a href="#规则：-1" class="headerlink" title="规则："></a>规则：</h4><p><strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<h4 id="案例详解：-1"><a href="#案例详解：-1" class="headerlink" title="案例详解："></a>案例详解：</h4><p><strong>例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</strong></p>
<ol>
<li>从左至右扫描，将3和4压入堆栈；</li>
<li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</li>
<li>将5入栈；</li>
<li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li>
<li>将6入栈；</li>
<li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果（下一个-顶部）</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇文章</title>
    <url>/posts/5c2fafc7.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script></p>
<h1 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h1><p><strong>今天是 2022 年的最后一天，加油 2023，再见 2022</strong><br></p>
<style>
</style>]]></content>
      <categories>
        <category>个人日记</category>
      </categories>
      <tags>
        <tag>happy</tag>
      </tags>
  </entry>
  <entry>
    <title>中缀转后缀</title>
    <url>/posts/4e31f605.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">中缀表达式转后缀表达式</span></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><strong>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式=&gt;1 2 3 + 4 × + 5 -</strong></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</p>
</li>
<li><p>从左至右扫描中缀表达式；</p>
</li>
<li><p>遇到操作数时，将其压s2；</p>
</li>
<li><p>遇到运算符时，比较其与s1栈顶运算符的优先级：</p>
<ol>
<li><p>如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</p>
</li>
<li><p>否则，若优先级比栈顶运算符的高，也将运算符压入s1；</p>
</li>
<li><p>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4. 1)与s1中新的栈顶运算符相比较；</p>
</li>
</ol>
</li>
<li><p>遇到括号时：</p>
<ol>
<li><p>如果是左括号“(”，则直接压入s1</p>
</li>
<li><p>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</p>
</li>
</ol>
</li>
<li><p>重复步骤2至5，直到表达式的最右边</p>
</li>
<li><p>将s1中剩余的运算符依次弹出并压入s2</p>
</li>
<li><p>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 </p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>扫描到的元素</th>
<th>s2(栈底-&gt;栈顶)</th>
<th>s1 (栈底-&gt;栈顶)</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>空</td>
<td>数字，直接入栈</td>
</tr>
<tr>
<td>+</td>
<td>1</td>
<td>+</td>
<td>s1为空，运算符直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td>+ (</td>
<td>左括号，直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td>+ ( (</td>
<td>同上</td>
</tr>
<tr>
<td>2</td>
<td>1 2</td>
<td>+ ( (</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>1 2</td>
<td>+ ( ( +</td>
<td>s1栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>3</td>
<td>1 2 3</td>
<td>+ ( ( +</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 +</td>
<td>+ (</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>×</td>
<td>1 2 3 +</td>
<td>+ ( ×</td>
<td>s1栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>4</td>
<td>1 2 3 + 4</td>
<td>+ ( ×</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 + 4 ×</td>
<td>+</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>-</td>
<td>1 2 3 + 4 × +</td>
<td>-</td>
<td>-与+优先级相同，因此弹出+，再压入-</td>
</tr>
<tr>
<td>5</td>
<td>1 2 3 + 4 × + 5</td>
<td>-</td>
<td>数字</td>
</tr>
<tr>
<td>到达最右端</td>
<td>1 2 3 + 4 × + 5 -</td>
<td>空</td>
<td>s1中剩余的运算符</td>
</tr>
</tbody>
</table>
</div>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//讲中缀表达式转化为List</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixList</span> <span class="params">( String s )</span> &#123;</span><br><span class="line">    <span class="comment">//先定义一个list,存放中缀表达式对应的内容</span></span><br><span class="line">    List&lt;String&gt; ls=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; (  ) ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这是一个指针用于遍历中缀表达式字符串</span></span><br><span class="line">    String str;<span class="comment">//多位数拼接</span></span><br><span class="line">    <span class="type">char</span> c;<span class="comment">//每遍历到一个字符就放入到c中</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果c是一个非数字，需要加到ls</span></span><br><span class="line">        <span class="keyword">if</span> ( (c=s.charAt ( i ))&lt;<span class="number">48</span> ||(c=s.charAt ( i ))&gt;<span class="number">57</span>&amp;&amp;(c=s.charAt ( i ))!=<span class="string">&#x27;.&#x27;</span> )&#123;  <span class="comment">//ASCII表48-57是数字</span></span><br><span class="line">            ls.add ( <span class="string">&quot;&quot;</span> + c );</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str = <span class="string">&quot;&quot;</span>;<span class="comment">//先将str置空</span></span><br><span class="line">            <span class="keyword">while</span> ((i&lt;s.length ()&amp;&amp;((c=s.charAt ( i ))&gt;=<span class="number">48</span>&amp;&amp;(c=s.charAt ( i ))&lt;=<span class="number">57</span>)) )&#123;</span><br><span class="line">                str += c;<span class="comment">//拼接</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ls.add ( str );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; s.length ( ));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将得到的中缀表达式对应的List=&gt;后缀对应的List</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">turnSuffixExpression</span> <span class="params">( List&lt;String&gt; ls )</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个栈</span></span><br><span class="line">    Stack&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt; ( );</span><br><span class="line">    <span class="comment">//s2栈在整个过程没有弹出操作，又因为最后要逆序输出，所以使用ArrayList</span></span><br><span class="line">    List&lt;String&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; ( );<span class="comment">//用于存储中间结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历ls</span></span><br><span class="line">    <span class="keyword">for</span> ( String i:ls )&#123;</span><br><span class="line">        <span class="comment">//如果是一个数，加入s2</span></span><br><span class="line">        <span class="keyword">if</span> ( i.matches ( <span class="string">&quot;\\d+&quot;</span> ) ) &#123;</span><br><span class="line">            s2.add ( i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( i.equals ( <span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">            s1.push ( i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i.equals ( <span class="string">&quot;)&quot;</span> ))&#123;</span><br><span class="line">            <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">            <span class="keyword">while</span> (!s1.peek ( ).equals ( <span class="string">&quot;(&quot;</span> )) &#123;  <span class="comment">//s1.peek()查看栈顶内容，但不弹出;如果栈顶没有到达（就不停止，继续弹</span></span><br><span class="line">                s2.add ( s1.pop ( ) );</span><br><span class="line">            &#125;</span><br><span class="line">            s1.pop ();<span class="comment">//将（弹出s1,消除小括号</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//若i优先级&lt;=栈顶运算符将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较；</span></span><br><span class="line">            <span class="comment">//缺少比较一个运算符优先级高低的方法</span></span><br><span class="line">            <span class="keyword">while</span> (s1.size ()!=<span class="number">0</span>&amp;&amp; Operation.getValue ( s1.peek () )&gt;=Operation.getValue (  i))&#123;</span><br><span class="line">                s2.add ( s1.pop ( ) );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//// 比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">            s1.push ( i );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将s1中剩下的运算符依次加入到s2中</span></span><br><span class="line">    <span class="keyword">while</span> (s1.size ( ) != <span class="number">0</span>) &#123;</span><br><span class="line">        s2.add ( s1.pop() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为是存放到list中，正常输出即为后缀表达式</span></span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成中缀表达式转后缀表达式</span></span><br><span class="line">        <span class="comment">//1. 1+（(2+3）*4）-5=&gt;转成1 2 3 + 4 × + 5 -</span></span><br><span class="line">        <span class="comment">//2.因为直接对字符串操作不方便，所以我们先将1+（(2+3）*4）-5转成中缀的list</span></span><br><span class="line">        <span class="comment">//  即1+（(2+3）*4）-5转为【1，+，（，（，2，+，3，），*，4，），-，5】</span></span><br><span class="line">        <span class="comment">//3.将得到的中缀表达式对应的List=&gt;后缀对应的List</span></span><br><span class="line">        <span class="comment">//即ArrayList【1，+，（，（，2，+，3，），*，4，），-，5】=&gt;[]</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((222+3)*4)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; list = toInfixList ( expression );</span><br><span class="line">        System.out.println (<span class="string">&quot;中缀表达式List=&quot;</span>+ list );</span><br><span class="line">        List&lt;String&gt; suffixlist    = turnSuffixExpression ( list );</span><br><span class="line">        System.out.println ( <span class="string">&quot;后缀表达式List=&quot;</span>+ suffixlist );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//讲中缀表达式转化为List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixList</span> <span class="params">( String s )</span> &#123;</span><br><span class="line">        <span class="comment">//先定义一个list,存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; (  ) ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这是一个指针用于遍历中缀表达式字符串</span></span><br><span class="line">        String str;<span class="comment">//多位数拼接</span></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//每遍历到一个字符就放入到c中</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果c是一个非数字，需要加到ls</span></span><br><span class="line">            <span class="keyword">if</span> ( (c=s.charAt ( i ))&lt;<span class="number">48</span> ||(c=s.charAt ( i ))&gt;<span class="number">57</span>&amp;&amp;(c=s.charAt ( i ))!=<span class="string">&#x27;.&#x27;</span> )&#123;  <span class="comment">//ASCII表48-57是数字</span></span><br><span class="line">                ls.add ( <span class="string">&quot;&quot;</span> + c );</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;<span class="comment">//先将str置空</span></span><br><span class="line">                <span class="keyword">while</span> ((i&lt;s.length ()&amp;&amp;((c=s.charAt ( i ))&gt;=<span class="number">48</span>&amp;&amp;(c=s.charAt ( i ))&lt;=<span class="number">57</span>)) )&#123;</span><br><span class="line">                    str += c;<span class="comment">//拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add ( str );</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; s.length ( ));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的List=&gt;后缀对应的List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">turnSuffixExpression</span> <span class="params">( List&lt;String&gt; ls )</span> &#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt; ( );</span><br><span class="line">        <span class="comment">//s2栈在整个过程没有弹出操作，又因为最后要逆序输出，所以使用ArrayList</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; ( );<span class="comment">//用于存储中间结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> ( String i:ls )&#123;</span><br><span class="line">            <span class="comment">//如果是一个数，加入s2</span></span><br><span class="line">            <span class="keyword">if</span> ( i.matches ( <span class="string">&quot;\\d+&quot;</span> ) ) &#123;</span><br><span class="line">                s2.add ( i );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( i.equals ( <span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                s1.push ( i );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i.equals ( <span class="string">&quot;)&quot;</span> ))&#123;</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek ( ).equals ( <span class="string">&quot;(&quot;</span> )) &#123;  <span class="comment">//s1.peek()查看栈顶内容，但不弹出;如果栈顶没有到达（就不停止，继续弹</span></span><br><span class="line">                    s2.add ( s1.pop ( ) );</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop ();<span class="comment">//将（弹出s1,消除小括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若i优先级&lt;=栈顶运算符将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较；</span></span><br><span class="line">                <span class="comment">//缺少比较一个运算符优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size ()!=<span class="number">0</span>&amp;&amp; Operation.getValue ( s1.peek () )&gt;=Operation.getValue (  i))&#123;</span><br><span class="line">                    s2.add ( s1.pop ( ) );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//// 比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">                s1.push ( i );</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩下的运算符依次加入到s2中</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size ( ) != <span class="number">0</span>) &#123;</span><br><span class="line">            s2.add ( s1.pop() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是存放到list中，正常输出即为后缀表达式</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个Operation的类可以返回运算符优先级高低</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ADD=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> SUB=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> MUL=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> DIV=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法返回优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span> <span class="params">( String operation )</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println (<span class="string">&quot;运算符有误&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230125225033538.png" alt="image-20230125225033538"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的应用</title>
    <url>/posts/bcd57b6.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">栈实现综合计算器</span><br><span class="p center small">栈——使用栈完成计算一个表达式的结果</span></p>
<p><strong>7<em> 2 </em> 2-5+1-5+3 -4？</strong></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230119000920072.png" alt="image-20230119000920072"></p>
<h3 id="栈的构建"><a href="#栈的构建" class="headerlink" title="栈的构建"></a>栈的构建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个栈</span></span><br><span class="line"><span class="comment">//定义一个ArrayStack2表示栈，需要扩展功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;  <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">//  用数组模拟栈，数据就放到该数组中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">//top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack2</span> <span class="params">( <span class="type">int</span> maxSize )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="built_in">this</span>.maxSize ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈——push</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span> <span class="params">( <span class="type">int</span> value )</span> &#123;</span><br><span class="line">        <span class="comment">//先判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span> ( isFull ( ) ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;栈满&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[ top ] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈——pop,将栈顶数据返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">pop</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( isEmpty ( ) ) &#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span> ( <span class="string">&quot;栈空，没有数据&quot;</span> );   <span class="comment">//运行异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[ top ];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈,遍历时从栈顶到栈底</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( isEmpty ( ) ) &#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;栈空没有数据~&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top ; i &gt;= <span class="number">0</span> ; i-- ) &#123;</span><br><span class="line">            System.out.printf ( <span class="string">&quot;stack[%d]=%d\n&quot;</span>,i,stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算附的优先级，优先级使用数字表示，数字越大，表示优先级越高</span></span><br><span class="line">    <span class="comment">//局限，目前的表达式只有+、-、*、/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span> <span class="params">( <span class="type">int</span> oper)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( oper == <span class="string">&#x27;+&#x27;</span>|| oper == <span class="string">&#x27;-&#x27;</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是不是一个运算附</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span> <span class="params">( <span class="type">char</span> oper )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span> || oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num1  最先弹出的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num2  第二个弹出的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oper  弹出的运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  res 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span> <span class="params">( <span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper )</span> &#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>; <span class="comment">//res表示计算结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num2 * num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以返回当前栈顶的值，单并不出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[ top ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;7*2*2-5+1-5+3-4&quot;</span>;   <span class="comment">//中缀表达式</span></span><br><span class="line">        <span class="comment">//创建两个栈，数栈和符号栈</span></span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">numStack</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span> ( <span class="number">10</span> );</span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">operStack</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span> ( <span class="number">10</span> );</span><br><span class="line">        <span class="comment">//定义变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//用于扫描</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;  <span class="comment">//将每次扫描的char保存到ch里</span></span><br><span class="line">        String keepnum=<span class="string">&quot;&quot;</span>;  <span class="comment">//多位数</span></span><br><span class="line">        <span class="comment">//开始while语句，循环扫描expression</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//依次得到expression的每一个字符</span></span><br><span class="line">            ch = expression.substring ( index, index + <span class="number">1</span> ).charAt ( <span class="number">0</span> );  <span class="comment">//取出一个字符串后，charAt取第一个字符</span></span><br><span class="line">            <span class="comment">//判断是否是数字还是字符，并做相应处理</span></span><br><span class="line">            <span class="keyword">if</span> ( operStack.isOper ( ch ) ) &#123;  <span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断当前的符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span> ( operStack.isEmpty ( ) ) &#123;</span><br><span class="line">                   <span class="comment">//直接入</span></span><br><span class="line">                    operStack.push ( ch );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//判断优先级、</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果当前的优先级小于或者等于栈中的操作符</span></span><br><span class="line">                    <span class="comment">//就需要从数栈中pop出两个数在从符号栈中pop出一个符号，进行运算，</span></span><br><span class="line">                    <span class="comment">//将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span> ( operStack.priority ( ch ) &lt;= operStack.priority ( operStack.peek ( ) ) ) &#123;</span><br><span class="line">                        num1 = numStack.pop ( );</span><br><span class="line">                        num2 = numStack.pop ( );</span><br><span class="line">                        oper=operStack.pop ( );</span><br><span class="line">                        res = numStack.cal ( num1, num2, oper );</span><br><span class="line">                        <span class="comment">//把运算的结果入数栈</span></span><br><span class="line">                        numStack.push ( res );</span><br><span class="line">                        <span class="comment">//然后把当前的符号入符号栈</span></span><br><span class="line">                        operStack.push ( ch  );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//大于，直接入符号栈</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        operStack.push ( ch );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//数字直接入栈</span></span><br><span class="line">                <span class="comment">//numStack.push ( ch-48 );  // &#x27;1&#x27;=49 而真实是1</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理多位数时，不能的发现是一个数就入栈，有可能是多位数</span></span><br><span class="line">                <span class="comment">//在处理数时，需要向expression的表达式的index后在看一位，如果是数进行扫描，如果不是数就停止</span></span><br><span class="line">                <span class="comment">//因此我们需要定义一个字符串变量，用于拼接</span></span><br><span class="line"></span><br><span class="line">                keepnum+=ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断ch是否是最后一个</span></span><br><span class="line">                <span class="keyword">if</span> ( index==expression.length()-<span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push ( Integer.parseInt ( keepnum ) );</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字就继续扫描</span></span><br><span class="line">                    <span class="comment">//index本身值不变</span></span><br><span class="line">                    <span class="keyword">if</span> ( operStack.isOper ( expression.substring ( index + <span class="number">1</span>, index + <span class="number">2</span> ).charAt ( <span class="number">0</span> ) ) ) &#123;</span><br><span class="line">                        numStack.push ( Integer.parseInt ( keepnum ) );  <span class="comment">//Integer.parseInt ( keepnum )字符串转数字</span></span><br><span class="line">                        <span class="comment">//！！！重要 ,keepnum清空</span></span><br><span class="line">                        keepnum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让index+1，并判断是否到最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> ( index &gt;= expression.length ( ) ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (!operStack.isEmpty ()) &#123;  <span class="comment">//通过符号栈来判断数栈</span></span><br><span class="line">            num1 = numStack.pop ( );</span><br><span class="line">            num2 = numStack.pop ( );</span><br><span class="line">            oper=operStack.pop ( );</span><br><span class="line">            res = numStack.cal ( num1, num2, oper );</span><br><span class="line">            numStack.push ( res );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//讲数栈的最后一个数pop出</span></span><br><span class="line">        System.out.printf (<span class="string">&quot;表达式 %s = %d&quot;</span>,expression,numStack.pop ( ));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰计算器(上)</title>
    <url>/posts/70f94a48.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">逆波兰计算器(上))</span><br><span class="p center small">栈——通过逆波兰计算式构建计算器</span></p>
<ul>
<li><p>输入一个逆波兰表达式(后缀表达式)，使用栈(Stack), 计算其结果</p>
</li>
<li><p>支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对<strong>整数</strong>的计算。</p>
</li>
</ul>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><strong>已知后缀进行计算</strong></p>
<p>​     (3+4)×5-6 =&gt;3 4 + 5 × 6 -</p>
<ol>
<li>从左至右扫描，将3和4压入堆栈；</li>
<li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</li>
<li>将5入栈；</li>
<li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li>
<li>将6入栈；</li>
<li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果（下一个-顶部）</li>
</ol>
<h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(3+4)*5-6 =&gt; 3 4 + 5 * 6 -</span></span><br><span class="line">        <span class="comment">//4*5-8+60+8/2=4 5 * 8 - 60 + 8 2 / +</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;4 5 * 8 - 60 + 8 2 / +&quot;</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将“3 4 + 5 * 6 -”=&gt; 放入ArrayList</span></span><br><span class="line">        <span class="comment">//2. 将ArrayList 传递给一个方法，遍历ArrayList 配合栈完成计算</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; reList = getListStrings ( suffixExpression );</span><br><span class="line">        System.out.println (<span class="string">&quot;reList=&quot;</span>+reList );</span><br><span class="line">        <span class="type">int</span> res=calculate ( reList );</span><br><span class="line">        System.out.println (<span class="string">&quot;运算结果为: &quot;</span>+res );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListStrings</span> <span class="params">( String suffixEpression )</span> &#123;</span><br><span class="line">        <span class="comment">//将suffixEpression分割</span></span><br><span class="line">        String[] spilt=suffixEpression.split ( <span class="string">&quot; &quot;</span> );  <span class="comment">//以空格来分割</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; ( );</span><br><span class="line">        <span class="keyword">for</span> ( String element : spilt ) &#123;  <span class="comment">//将分割后的数依次循环</span></span><br><span class="line">            list.add( element );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">     * 2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">     * 3. 将5入栈；</span></span><br><span class="line"><span class="comment">     * 4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">     * 5. 将6入栈；</span></span><br><span class="line"><span class="comment">     * 6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果（下一个-顶部）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span> <span class="params">( List&lt;String&gt; ls)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt; ( );</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> ( String s : ls ) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取多位数</span></span><br><span class="line">            <span class="keyword">if</span> ( s.matches (<span class="string">&quot;\\d+&quot;</span>  ) )&#123;<span class="comment">//匹配多位数  s.matches来匹配数字“\\d+&quot;(+)表示一到多</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push ( s );</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//栈中弹出两个数，并运算，计算结果在入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt (stack.pop ( ));</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt (stack.pop ( ));</span><br><span class="line">                <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;+&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;-&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;*&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;/&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span> ( <span class="string">&quot;运算符完毕&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push (  <span class="string">&quot;&quot;</span>+res );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据为运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt (stack.pop ( ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong><br><div class="hide-block"><button type="button" class="hide-button" style="background-color:  pick;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230119232552897.png" alt="image-20230119232552897" style="zoom:67%;"></p>
</div></div></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/posts/1ac49179.html</url>
    <content><![CDATA[<span class="p center logo large">Shell Sort</span>
<span class="p center small">排序算法——希尔排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>

<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>希尔排序也是一种<emp>插入排序</emp>，它是简单插入排序经过改进之后的一个更高效的版本，也称为<emp>缩小增量排序</emp>。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p>
<h3 id="思路图解图"><a href="#思路图解图" class="headerlink" title="思路图解图"></a>思路图解图</h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230219172508741.png" alt="image-20230219172508741"></p>
<p><code>先根据不断分组来进行排序，最后当gap等于1进行插入排序</code></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><h4 id="交换法"><a href="#交换法" class="headerlink" title="交换法"></a>交换法</h4><div class="tip ban faa-parent animated-hover"><p class="faa-flash">速度较慢，和冒泡时间差不多</p></div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序插入交换法（速度太慢）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSorting1</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span> ; gap &gt; <span class="number">0</span> ; gap /= <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="type">int</span> temp ;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">            <span class="comment">//遍历各组中所有的元素（共gap组，每组10/gap个），步长gap</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap ; j &gt;= <span class="number">0</span> ; j -= gap ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( arr[ j ] &gt; arr[ j + gap ] ) &#123;</span><br><span class="line">                    temp           = arr[ j ];</span><br><span class="line">                    arr[ j ]       = arr[ j + gap ];</span><br><span class="line">                    arr[ j + gap ] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( <span class="string">&quot;希尔排序第&quot;</span> + ( x++ ) + <span class="string">&quot;轮&quot;</span> + Arrays.toString ( arr ) );</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println (<span class="string">&quot;交换法排序后&quot;</span>+ Arrays.toString (arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移动法"><a href="#移动法" class="headerlink" title="移动法"></a>移动法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序插入移动法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSorting2</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">    <span class="comment">//增量gap,并逐步的缩小增量</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span> ; gap &gt; <span class="number">0</span> ; gap /= <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对所在的组进行直接插入排序</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];  <span class="comment">//用一个变量接收待变化的数</span></span><br><span class="line">            <span class="keyword">if</span> ( arr[ j ] &lt; arr[ j - gap ] ) &#123; <span class="comment">//进入条件在这加比较，每次最多能省下2次判断</span></span><br><span class="line">                <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[ j-gap ] ) &#123; <span class="comment">//首先不能越界，其次这里比较是为了循环时j变化后进行再次比较判断</span></span><br><span class="line">                    arr[ j ] = arr[ j - gap ];</span><br><span class="line">                    j -= gap;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当while退出后，即找到插入的位置</span></span><br><span class="line">                <span class="comment">//能到这肯定是已经变化了</span></span><br><span class="line">                arr[ j ] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println (<span class="string">&quot;移动法排序后&quot;</span>+ Arrays.toString (arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>依旧是用80000个数来进行排序比较时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;;</span></span><br><span class="line"><span class="comment">//        shellSorting ( arr );</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000</span> ];</span><br><span class="line">        <span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000</span> ];</span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        randomArr ( arr1 );</span><br><span class="line"></span><br><span class="line">        System.out.println (<span class="string">&quot;希尔排序交换法所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序前时间是：&quot;</span>+date1String );</span><br><span class="line">        shellSorting1 ( arr );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序后时间是：&quot;</span>+date2String );</span><br><span class="line"></span><br><span class="line">        System.out.println (<span class="string">&quot;希尔排序移动法所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date3String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序前时间是：&quot;</span>+date3String );</span><br><span class="line">        shellSorting2 ( arr1 );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date4String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序后时间是：&quot;</span>+date4String );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序插入移动法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSorting2</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="comment">//增量gap,并逐步的缩小增量</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span> ; gap &gt; <span class="number">0</span> ; gap /= <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="comment">//从第gap个元素，逐个对所在的组进行直接插入排序</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];  <span class="comment">//用一个变量接收待变化的数</span></span><br><span class="line">                <span class="keyword">if</span> ( arr[ j ] &lt; arr[ j - gap ] ) &#123; <span class="comment">//进入条件在这加比较，每次最多能省下2次判断</span></span><br><span class="line">                    <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[ j-gap ] ) &#123; <span class="comment">//首先不能越界，其次这里比较是为了循环时j变化后进行再次比较判断</span></span><br><span class="line">                        arr[ j ] = arr[ j - gap ];</span><br><span class="line">                        j -= gap;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当while退出后，即找到插入的位置</span></span><br><span class="line">                    <span class="comment">//能到这肯定是已经变化了</span></span><br><span class="line">                    arr[ j ] = temp;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println (&quot;移动法排序后&quot;+ Arrays.toString (arr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序插入交换法（速度太慢）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSorting1</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span> ; gap &gt; <span class="number">0</span> ; gap /= <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="type">int</span> temp ;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">                <span class="comment">//遍历各组中所有的元素（共gap组，每组10/gap个），步长gap</span></span><br><span class="line">                <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap ; j &gt;= <span class="number">0</span> ; j -= gap ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( arr[ j ] &gt; arr[ j + gap ] ) &#123;</span><br><span class="line">                        temp           = arr[ j ];</span><br><span class="line">                        arr[ j ]       = arr[ j + gap ];</span><br><span class="line">                        arr[ j + gap ] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println ( &quot;希尔排序第&quot; + ( x++ ) + &quot;轮&quot; + Arrays.toString ( arr ) );</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println (&quot;交换法排序后&quot;+ Arrays.toString (arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先使用逐步推导来解决</span></span><br><span class="line">        <span class="comment">/*int temp = 0;</span></span><br><span class="line"><span class="comment">        //希尔排序的第一轮排序 10/2=5</span></span><br><span class="line"><span class="comment">        for ( int i = 5 ; i &lt; arr.length ; i++ ) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共五组，每组2个），步长5</span></span><br><span class="line"><span class="comment">            for ( int j = i - 5 ; j &gt;= 0 ; j -= 5 ) &#123;</span></span><br><span class="line"><span class="comment">                if ( arr[ j ] &gt; arr[ j + 5 ] ) &#123;</span></span><br><span class="line"><span class="comment">                    temp=arr[ j ];</span></span><br><span class="line"><span class="comment">                    arr[ j ] = arr[ j + 5 ];</span></span><br><span class="line"><span class="comment">                    arr[ j + 5 ] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println ( &quot;希尔排序第1轮&quot; + Arrays.toString ( arr ) );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //希尔排序的第二轮排序 5/2=2</span></span><br><span class="line"><span class="comment">        for ( int i = 2 ; i &lt; arr.length ; i++ ) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共2组，每组5个），步长2</span></span><br><span class="line"><span class="comment">            for ( int j = i - 2 ; j &gt;= 0 ; j -= 2 ) &#123;</span></span><br><span class="line"><span class="comment">                if ( arr[ j ] &gt; arr[ j + 2 ] ) &#123;</span></span><br><span class="line"><span class="comment">                    temp=arr[ j ];</span></span><br><span class="line"><span class="comment">                    arr[ j ] = arr[ j + 2 ];</span></span><br><span class="line"><span class="comment">                    arr[ j + 2 ] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println ( &quot;希尔排序第2轮&quot; + Arrays.toString ( arr ) );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //希尔排序的第二轮排序 2/2=1</span></span><br><span class="line"><span class="comment">        for ( int i = 1 ; i &lt; arr.length ; i++ ) &#123;</span></span><br><span class="line"><span class="comment">            //遍历各组中所有的元素（共1组，每组10个），步长1</span></span><br><span class="line"><span class="comment">            for ( int j = i - 1 ; j &gt;= 0 ; j -= 1 ) &#123;</span></span><br><span class="line"><span class="comment">                if ( arr[ j ] &gt; arr[ j + 1 ] ) &#123;</span></span><br><span class="line"><span class="comment">                                   temp=arr[ j ];</span></span><br><span class="line"><span class="comment">                    arr[ j ] = arr[ j + 1 ];</span></span><br><span class="line"><span class="comment">                    arr[ j + 1 ] = temp;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println ( &quot;希尔排序第3轮&quot; + Arrays.toString ( arr ) );*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++)&#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format(date1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>两种方法进行比较，时间差距十分的大</p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230219171738544.png" alt="image-20230219171738544"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/posts/1599bffe.html</url>
    <content><![CDATA[<span class="p center logo large">Merge Sort</span>
<span class="p center small">排序算法——归并排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>


<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><code>归并排序（MERGE-SORT）</code>是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<h3 id="思路图解"><a href="#思路图解" class="headerlink" title="思路图解"></a>思路图解</h3><p>分很简单，就是将数组中的数据，依次慢慢分开</p>
<p>这里的合，不光是将分好后的数据合起来，在合起来后的小数组进行排序调换，具体内容见图二。</p>
<p><strong>图一</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230221120848993.png" alt="image-20230221120848993"></p>
<p><strong>图二</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230221121334359.png" alt="image-20230221121334359" style="zoom:150%;"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><p><strong>代码部分有两块，第一块是<emp>分</emp>，通过递归，最终将数组最终分为单个元素，然后在顺着分的倒过来路线来<emp>合</emp>，通过<emp>治</emp>的方法，来比较大小，将排列好的数据给temp，temp最终将这段排好顺序的数组copy到原来这段的arr的位置。通过递归来分，接着递归的回溯来进行”治“从而在回溯完后数组的顺序也排完了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//分+合的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span> <span class="params">( <span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left &lt; right )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ( left + right ) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//先向左递归进行分解</span></span><br><span class="line">            mergeSort ( arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort ( arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            Merge ( arr,left,mid,right,temp );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 做中转数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Merge</span> <span class="params">( <span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;  <span class="comment">//初始化i,</span></span><br><span class="line">        <span class="type">int</span> j=mid+<span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//temp索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一</span></span><br><span class="line">        <span class="comment">//先把左右两边（有序）的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完成</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123; <span class="comment">//继续</span></span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边的有序序列当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素填充到temp数组里</span></span><br><span class="line">            <span class="comment">// 然后t++,i++</span></span><br><span class="line">            <span class="keyword">if</span> ( arr[i]&lt;=arr[j] ) &#123;</span><br><span class="line">                temp[ t ] = arr[ i ];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">//反之将右边添加进去</span></span><br><span class="line">                temp[ t ] = arr[ j ];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二把剩余数据的一边全部填入temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;  <span class="comment">//说明左边元素还有剩余，将全部填充到temp</span></span><br><span class="line">            temp[ t ] = arr[ i ];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[ t ] = arr[ j ];</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意，并不是每次拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">templeft</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//第一合并0-&gt;1</span></span><br><span class="line">        <span class="comment">//最后一次合并就是0-&gt;arr.length-1</span></span><br><span class="line"><span class="comment">//        System.out.println (&quot;templeft:&quot;+templeft+&quot;right:&quot;+right );</span></span><br><span class="line">        <span class="keyword">while</span> (templeft &lt;= right) &#123;</span><br><span class="line">            arr[ templeft ] = temp[ t ];</span><br><span class="line">            t++;</span><br><span class="line">            templeft++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>在强大的算法前之前的8万数据已经无法在检验它的性能，直接上8000万</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergetSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"><span class="comment">/*        int arr[] = &#123;8, 4, 5, 1, 3, 6, 2,10,11,9,-2&#125;;</span></span><br><span class="line"><span class="comment">        int temp[] = new int[ arr.length ];  //归并排序需要额外的空间</span></span><br><span class="line"><span class="comment">        mergeSort ( arr,0,arr.length-1,temp );</span></span><br><span class="line"><span class="comment">        System.out.println (&quot;归并排序&quot;+ Arrays.toString(arr) );*/</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000000</span> ];</span><br><span class="line">        <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[ arr.length ];  <span class="comment">//归并排序需要额外的空间</span></span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        System.out.println ( <span class="string">&quot;归并排序8000万数据所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println ( <span class="string">&quot;排序前时间是：&quot;</span> + date1String );</span><br><span class="line">        mergeSort ( arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println ( <span class="string">&quot;排序后时间是：&quot;</span> + date2String );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span> <span class="params">( <span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left &lt; right )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ( left + right ) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//先向左递归进行分解</span></span><br><span class="line">            mergeSort ( arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort ( arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            Merge ( arr,left,mid,right,temp );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 做中转数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Merge</span> <span class="params">( <span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;  <span class="comment">//初始化i,</span></span><br><span class="line">        <span class="type">int</span> j=mid+<span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//temp索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//一</span></span><br><span class="line">        <span class="comment">//先把左右两边（有序）的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完成</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123; <span class="comment">//继续</span></span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边的有序序列当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素填充到temp数组里</span></span><br><span class="line">            <span class="comment">// 然后t++,i++</span></span><br><span class="line">            <span class="keyword">if</span> ( arr[i]&lt;=arr[j] ) &#123;</span><br><span class="line">                temp[ t ] = arr[ i ];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">//反之将右边添加进去</span></span><br><span class="line">                temp[ t ] = arr[ j ];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二把剩余数据的一边全部填入temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;  <span class="comment">//说明左边元素还有剩余，将全部填充到temp</span></span><br><span class="line">            temp[ t ] = arr[ i ];</span><br><span class="line">            i++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[ t ] = arr[ j ];</span><br><span class="line">            j++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意，并不是每次拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">templeft</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//第一合并0-&gt;1</span></span><br><span class="line">        <span class="comment">//最后一次合并就是0-&gt;arr.length-1</span></span><br><span class="line"><span class="comment">//        System.out.println (&quot;templeft:&quot;+templeft+&quot;right:&quot;+right );</span></span><br><span class="line">        <span class="keyword">while</span> (templeft &lt;= right) &#123;</span><br><span class="line">            arr[ templeft ] = temp[ t ];</span><br><span class="line">            t++;</span><br><span class="line">            templeft++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format ( date1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230221154041296.png" alt="image-20230221154041296"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/posts/14e6f1eb.html</url>
    <content><![CDATA[<span class="p center logo large">Bubble Sort</span>
<span class="p center small">排序算法——冒泡排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong><code>冒泡排序（Bubble Sorting）</code>的基本思想是：</strong></p>
<p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序(与自己制定的顺序相反)则交换，使值较大的元素逐渐从前移向后部</p>
<p><strong>优化：</strong></p>
<p>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序，</strong>因此要在排序过程中<strong>设置一个标志flag判断元素是否进行过交换</strong>。从而减少不必要的比较,来达到算法优化。</p>
<h3 id="冒泡过程图解："><a href="#冒泡过程图解：" class="headerlink" title="冒泡过程图解："></a><strong>冒泡过程图解：</strong></h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230204162842489.png" alt="image-20230204162842489" style="zoom:80%;"></p>
<p><strong>小结:</strong></p>
<ol>
<li><p>一共进行 数组的大小-1 次 大的循环</p>
</li>
<li><p>每一趟排序的次数在逐渐的减少</p>
</li>
<li>如果我们发现在某趟排序中，没有发生一次交换， 可以提前结束冒泡排序。这个就是优化</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="无优化"><a href="#无优化" class="headerlink" title="无优化"></a>无优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无优化的冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Sort</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">    System.out.println (<span class="string">&quot;排序之前&quot;</span>+Arrays.toString ( arr ) );</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length-<span class="number">1</span> - i ; j++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( arr[j]&gt;arr[j+<span class="number">1</span>] )&#123;</span><br><span class="line">                temp = arr[ j ];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[ j + <span class="number">1</span> ] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf (<span class="string">&quot;第%d趟排序，结果是&quot;</span>,i+<span class="number">1</span> );</span><br><span class="line">        System.out.println ( Arrays.toString( arr ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有优化的冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SortPro</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">    System.out.println (<span class="string">&quot;排序之前&quot;</span>+Arrays.toString ( arr ) );</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length-<span class="number">1</span> - i ; j++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( arr[j]&gt;arr[j+<span class="number">1</span>] )&#123;</span><br><span class="line">                temp = arr[ j ];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[ j + <span class="number">1</span> ] = temp;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf (<span class="string">&quot;第%d趟排序，结果是&quot;</span>,i+<span class="number">1</span> );</span><br><span class="line">        System.out.println ( Arrays.toString( arr ) );</span><br><span class="line">        <span class="keyword">if</span> ( flag )&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化性比较"><a href="#优化性比较" class="headerlink" title="优化性比较"></a>优化性比较</h3><p><strong>创建80000个随机数据的数组 <emp>arr,arr1</emp> ,分别进行排序比较优化后的代码提示多少</strong>（<em>具体时间跟硬件有关，大致优化时间可参照</em>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">       <span class="comment">/* int arr[] = &#123;3, 9, -1, 10, -2 &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //将冒泡排序的演变过程展示一遍</span></span><br><span class="line"><span class="comment">        //每趟排序，将最大的依次从最后往前</span></span><br><span class="line"><span class="comment">        SortPro ( arr );</span></span><br><span class="line"><span class="comment">        System.out.println (&quot;排序完结果是&quot;+Arrays.toString( arr ) );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试冒泡的速度O(n^2),给80000个数据测试</span></span><br><span class="line">        <span class="comment">//创建80000个数据的随机数组</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000</span> ];</span><br><span class="line">        <span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000</span> ];</span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        randomArr ( arr1 );</span><br><span class="line"></span><br><span class="line">        System.out.println (<span class="string">&quot;无优化所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序前时间是：&quot;</span>+date1String );</span><br><span class="line">        Sort ( arr );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序后时间是：&quot;</span>+date2String );</span><br><span class="line"></span><br><span class="line">        System.out.println (<span class="string">&quot;有优化所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date3String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序前时间是：&quot;</span>+date3String );</span><br><span class="line">        SortPro ( arr1 );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date4String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序后时间是：&quot;</span>+date4String );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++)&#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format(date1 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无优化的冒泡排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Sort</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println (&quot;排序之前&quot;+Arrays.toString ( arr ) );</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length-<span class="number">1</span> - i ; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( arr[j]&gt;arr[j+<span class="number">1</span>] )&#123;</span><br><span class="line">                    temp = arr[ j ];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[ j + <span class="number">1</span> ] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.printf (&quot;第%d趟排序，结果是&quot;,i+1 );</span></span><br><span class="line"><span class="comment">//            System.out.println ( Arrays.toString( arr ) );</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有优化的冒泡排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SortPro</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println (&quot;排序之前&quot;+Arrays.toString ( arr ) );</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length-<span class="number">1</span> - i ; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( arr[j]&gt;arr[j+<span class="number">1</span>] )&#123;</span><br><span class="line">                    temp = arr[ j ];</span><br><span class="line">                    arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[ j + <span class="number">1</span> ] = temp;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.printf (&quot;第%d趟排序，结果是&quot;,i+1 );</span></span><br><span class="line"><span class="comment">//            System.out.println ( Arrays.toString( arr ) );</span></span><br><span class="line">            <span class="keyword">if</span> ( flag )&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230204163845864.png" alt="image-20230204163845864" style="zoom:80%;"></p>
<p>在多次实验下，结果依旧不变，大致可以确定，该优化能提升1/10的性能，但依于冒泡排序虽稳定，但时间复杂度较高，数据大时不建议用！！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/posts/ff8068c0.html</url>
    <content><![CDATA[<span class="p center logo large">Quick Sort</span>
<span class="p center small">排序算法——快速排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>

<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>快速排序（Quicksort）是对冒泡排序的一种改进。<strong>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，<emp>整个排序过程可以递归进行，</emp>以此达到整个数据变成有序序列</strong></p>
<h3 id="思路图解"><a href="#思路图解" class="headerlink" title="思路图解"></a>思路图解</h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230220174000919.png" alt="image-20230220174000919"></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230220174224713.png" alt="image-20230220174224713" style="zoom: 50%;"></p>
<p>第一轮找基准分两组后，以基准为界将比基准大的放在右边，比基准小的放在左边。然后交换完以后产生的左右两组在分别以第一轮的样子在交换，往下递归交换，最终有序，<emp>这个方法是非常典型的以空间换时间</emp></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><p>此时，该算法有点不理解，代码仅仅只是会写，并没有真正领悟，代码旁边备注不够详细。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span> <span class="params">( <span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=left; <span class="comment">//左下标</span></span><br><span class="line">    <span class="type">int</span> r=right; <span class="comment">//右下标</span></span><br><span class="line">    <span class="comment">//pivot 中轴</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span>arr[(left+right)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> temp ; <span class="comment">//中间变量</span></span><br><span class="line">    <span class="comment">//while循环的目的是让比pivot的值小放到左边</span></span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        <span class="comment">//在pivot的左边一直找，找到大于等于piovt值，才退出</span></span><br><span class="line">        <span class="keyword">while</span> (arr[l]&lt;pivot)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在pivot的右边一直找，找到小于等于piovt值，才退出</span></span><br><span class="line">        <span class="keyword">while</span> (arr[ r ] &gt; pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//piovt左边小于piovt,piovt右边大于piovt,</span></span><br><span class="line">        <span class="keyword">if</span> ( l&gt;=r )&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        temp=arr[l];</span><br><span class="line">        arr[ l ] = arr[ r ];</span><br><span class="line">        arr[ r ] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果交换完后，发现这个arr[l]==piovt值 此时让r--，前移</span></span><br><span class="line">        <span class="comment">//说明到中点了，这样--或++使其退出循环</span></span><br><span class="line">        <span class="keyword">if</span> ( arr[ l ] == pivot ) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果交换完后，发现这个arr[r]==piovt值 此时让l++，后移</span></span><br><span class="line">        <span class="keyword">if</span> ( arr[ r ] == pivot ) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果l==r ,必须l++，r--,否在出现栈溢出</span></span><br><span class="line">    <span class="keyword">if</span> ( l == r ) &#123;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> ( left&lt;r )&#123;</span><br><span class="line">        quickSort ( arr, left, r );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> ( right&gt;l )&#123;</span><br><span class="line">        quickSort ( arr, l, right );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="推算"><a href="#推算" class="headerlink" title="推算"></a>推算</h4><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230220191732140.png" alt="image-20230220191732140" style="zoom: 33%;"></p>
</div></div>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>因为该算法处理排序较快，所以单以8万的数据量无法体现它的优越性，所以选择更加庞大的80万，按道理数据增大十倍，时间应该呈现几何式增长，单从肉眼看结果并没明显体现，这就说明它的优越性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">/*int[] arr = &#123;-9, 78, 0, 23, -567, 70,-1,26,-567,256&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        quickSort ( arr, 0, arr.length - 1 );</span></span><br><span class="line"><span class="comment">        System.out.println ( &quot;arr :&quot; + Arrays.toString ( arr ) );*/</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">8000000</span> ];</span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        System.out.println ( <span class="string">&quot;插入排序所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println ( <span class="string">&quot;排序前时间是：&quot;</span> + date1String );</span><br><span class="line">        quickSort ( arr,<span class="number">0</span>,arr.length - <span class="number">1</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println ( <span class="string">&quot;排序后时间是：&quot;</span> + date2String );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span> <span class="params">( <span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l=left; <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> r=right; <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span>arr[(left+right)/<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> temp ; <span class="comment">//中间变量</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot的值小放到左边</span></span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找，找到大于等于piovt值，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[l]&lt;pivot)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找，找到小于等于piovt值，才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[ r ] &gt; pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//piovt左边小于piovt,piovt右边大于piovt,</span></span><br><span class="line">            <span class="keyword">if</span> ( l&gt;=r )&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp=arr[l];</span><br><span class="line">            arr[ l ] = arr[ r ];</span><br><span class="line">            arr[ r ] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l]==piovt值 此时让r--，前移</span></span><br><span class="line">            <span class="comment">//说明到中点了，这样--或++使其退出循环</span></span><br><span class="line">            <span class="keyword">if</span> ( arr[ l ] == pivot ) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r]==piovt值 此时让l++，后移</span></span><br><span class="line">            <span class="keyword">if</span> ( arr[ r ] == pivot ) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果l==r ,必须l++，r--,否在出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> ( l == r ) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> ( left&lt;r )&#123;</span><br><span class="line">            quickSort ( arr, left, r );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> ( right&gt;l )&#123;</span><br><span class="line">            quickSort ( arr, l, right );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format ( date1 );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230220180307863.png" alt="image-20230220180307863"><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230220180406264.png" alt="image-20230220180406264"><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230220180720746.png" alt="image-20230220180720746"></p>
<p>后期，等排序学完，将7种常见排序进行速度比较。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法 初始</title>
    <url>/posts/ba3a2e36.html</url>
    <content><![CDATA[<span class="p center logo large">初始排序算法</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>

<p>排序也称排序算法(Sort <code>Algorithm</code>)，排序是将<strong>一组数据</strong>，依指定的顺序进行<strong>排列的过程</strong>。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><p><strong>内部排序</strong></p>
<p>指将需要处理的所有数据都加载到内部存储器中进行排序。</p>
</li>
<li><p><strong>外部排序法</strong></p>
<p>数据量过大，无法全部加载到内存中，需要借助外部存储（文件、磁盘）进行排序。</p>
</li>
<li><p><strong>常见的排序算法</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230129223508784.png" alt="image-20230129223508784" style="zoom:67%;"></p>
</li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><strong>度量一个程序(算法)执行时间的两种方法</strong></p>
<ol>
<li><code>事后统计</code>的方法这种方法可行, 但是有两个问题：<ol>
<li>要想对设计的算法的运行性能进行评测，需要实际运行该程序；</li>
<li>所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</li>
</ol>
</li>
<li><code>事前估算</code>的方法通过分析某个算法的 <emp>时间复杂度</emp> 来判断哪个算法更优.</li>
</ol>
<h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。<strong><emp>一个算法中的语句执行次数称为语句频度或时间频度</emp></strong>。记为<strong>T(n)</strong>。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>忽略常数项</p>
</li>
<li><p>忽略低次项</p>
</li>
<li><p>忽略系数</p>
</li>
</ol>
<p>通过最高次幂来估算他们的时间复杂度T(n)=<code>不要系数的最高次幂</code></p>
<p>​    例：$T(n)=3n^{3}+5n-6 =&gt;n^{3} =&gt;O(n^3)$</p>
<h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><ol>
<li><p><strong>常数阶$O(1)$</strong></p>
<ul>
<li><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130174722607.png" alt="image-20230130174722607" style="zoom:80%;"></p>
</li>
</ul>
</li>
<li><p><strong>对数阶$O(log_2 n)$</strong></p>
<ul>
<li>在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = $ log_2 n $ 也就是说当循环 $log_2 n$ 次以后，这个代码就结束了。因此这个代码的时间复杂度为：$O(log_2 n)$ 。 $O(log_2 n)$ 的这个2 时间上是根据代码变化的，i = i * 3 ，则是$ O(log_3 n)$ .<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130175154657.png" alt="image-20230130175154657" style="zoom:80%;"></li>
</ul>
</li>
<li><p><strong>线性阶$O(n)$</strong></p>
<ul>
<li>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130175321034.png" alt="image-20230130175321034" style="zoom:80%;"></li>
</ul>
</li>
<li><p><strong>线性对数阶 $O(nlog_2 n)$ </strong></p>
<ul>
<li>将时间复杂度为O(log<em>N) 的代码循环n遍的话，那么它的时间复杂度就是 n * O(log N)，也就是了 O(nlogN</em>)<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130175539762.png" alt="image-20230130175539762" style="zoom:80%;"></li>
</ul>
</li>
<li><p><strong>平方阶 $O(n^2)$ </strong></p>
<ul>
<li>就是嵌套了2层n循环，它的时间复杂度就是 O(n x n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m x n)<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130175726982.png" alt="image-20230130175726982" style="zoom:80%;"></li>
</ul>
</li>
<li><p><strong>立方阶$O(n^3)$</strong></p>
<ul>
<li>相当于3层n循环</li>
</ul>
</li>
<li><p><strong>k次方阶$O(n^k)$</strong></p>
<ul>
<li>想当于k层n循环</li>
</ul>
</li>
<li><p><strong>指数阶$O(2^n)$</strong></p>
<ul>
<li>相当于 $O(log_2 n)$ 反过来</li>
</ul>
</li>
</ol>
<p>常见的算法时间复杂度由小到大依次为： </p>
<script type="math/tex; mode=display">
 Ο(1)＜Ο(log_2 n)＜Ο(n)＜Ο(nlog_2 n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜Ο(2^n)</script><p>常见的时间复杂度对应的图：</p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130174648040.png" alt="image-20230130174648040"></p>
<h3 id="平均、最坏时间复杂度"><a href="#平均、最坏时间复杂度" class="headerlink" title="平均、最坏时间复杂度"></a>平均、最坏时间复杂度</h3><ul>
<li><code>平均时间复杂度</code>是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</li>
<li>最坏情况下的时间复杂度称<code>最坏时间复杂度</code>。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230130180918761.png" alt="image-20230130180918761" style="zoom:80%;"></p>
<p>总结：在处理数据量大的时候可以选择快排、归并、堆</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><ol>
<li>类似于时间复杂度的讨论，一个算法的<code>空间复杂度</code>(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li>
<li>空间复杂度(Space Complexity)是<emp>对一个算法在运行过程中临时占用存储空间大小的量度</emp>。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序、归并排序、基数排序算法就属于这种情况。</li>
<li>在做算法分析时，主要讨论的是时间复杂度。<strong>从用户使用体验上看，更看重的程序执行的速度</strong>。一些缓存产品(redis, memcache)和算法(基数排序)本质就是<emp>用空间换时间</emp>。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/posts/71c610d3.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">单链表（SingleLinked List）初始</span><br><span class="p center small">链表——单链表</span><br><img src="/posts/71c610d3.htm/image-20230111234126554.jpg" alt="image-20230111234126554" style="zoom:67%;"><br><img src="/posts/71c610d3.htm/image-20230111234719805.png" alt="image-20230111234719805" style="zoom:67%;"></p>
<blockquote>
<p>小结</p>
<blockquote>
<p>链表是以节点的方式来存储</p>
<p>每个节点包括data域和next域</p>
<p>data域存值，next域指向下一个节点</p>
<p>链表       （带头节点的/不带头节点的）</p>
<label style="color:red">链表的各个节点不一定是连续存放的</label>

</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰计算器（下）</title>
    <url>/posts/c8452d2d.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">逆波兰计算器完整版</span><br><span class="p center small">栈——通过中缀转后缀在进行逆波兰计算式构建计算器</span><br><code>只能在运算式中出现数字（）+ - * /  .</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成中缀表达式转后缀表达式</span></span><br><span class="line">        <span class="comment">//1. 1+（(2+3）*4）-5=&gt;转成1 2 3 + 4 × + 5 -</span></span><br><span class="line">        <span class="comment">//2.因为直接对字符串操作不方便，所以我们先将1+（(2+3）*4）-5转成中缀的list</span></span><br><span class="line">        <span class="comment">//  即1+（(2+3）*4）-5转为【1，+，（，（，2，+，3，），*，4，），-，5】</span></span><br><span class="line">        <span class="comment">//3.将得到的中缀表达式对应的List=&gt;后缀对应的List</span></span><br><span class="line">        <span class="comment">//即ArrayList【1，+，（，（，2，+，3，），*，4，），-，5】=&gt;[]</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((22.222+3)*4.05)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; list = toInfixList ( expression );</span><br><span class="line">        System.out.println (<span class="string">&quot;中缀表达式List=&quot;</span>+ list );</span><br><span class="line">        List&lt;String&gt; suffixlist    = turnSuffixExpression ( list );</span><br><span class="line">        System.out.println ( <span class="string">&quot;后缀表达式List=&quot;</span>+ suffixlist );</span><br><span class="line">        <span class="type">float</span> res=calculate ( suffixlist );</span><br><span class="line">        System.out.printf ( <span class="string">&quot;%s=%f&quot;</span> ,expression, res );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//讲中缀表达式转化为List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixList</span> <span class="params">( String s )</span> &#123;</span><br><span class="line">        <span class="comment">//先定义一个list,存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; (  ) ;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这是一个指针用于遍历中缀表达式字符串</span></span><br><span class="line">        String str;<span class="comment">//多位数拼接</span></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//每遍历到一个字符就放入到c中</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果c是一个非数字，需要加到ls</span></span><br><span class="line">            <span class="keyword">if</span> ( (c=s.charAt ( i ))&lt;<span class="number">48</span> ||(c=s.charAt ( i ))&gt;<span class="number">57</span>&amp;&amp;(c=s.charAt ( i ))!=<span class="string">&#x27;.&#x27;</span> )&#123;  <span class="comment">//ASCII表48-57是数字</span></span><br><span class="line">                ls.add ( <span class="string">&quot;&quot;</span> + c );</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;<span class="comment">//先将str置空</span></span><br><span class="line">                <span class="keyword">while</span> ((i&lt;s.length ()&amp;&amp;((c=s.charAt ( i ))&gt;=<span class="number">48</span>&amp;&amp;(c=s.charAt ( i ))&lt;=<span class="number">57</span>||(c=s.charAt ( i ))==<span class="string">&#x27;.&#x27;</span>)) )&#123;</span><br><span class="line">                    str += c;<span class="comment">//拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add ( str );</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; s.length ( ));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的List=&gt;后缀对应的List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">turnSuffixExpression</span> <span class="params">( List&lt;String&gt; ls )</span> &#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt; ( );</span><br><span class="line">        <span class="comment">//s2栈在整个过程没有弹出操作，又因为最后要逆序输出，所以使用ArrayList</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; ( );<span class="comment">//用于存储中间结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> ( String i:ls )&#123;</span><br><span class="line">            <span class="comment">//如果是一个数，加入s2</span></span><br><span class="line">            <span class="keyword">if</span> ( i.matches ( <span class="string">&quot;\\d+&quot;</span> )|| i.matches ( <span class="string">&quot;\\d+.\\d+&quot;</span> )) &#123;</span><br><span class="line">                s2.add ( i );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( i.equals ( <span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                s1.push ( i );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i.equals ( <span class="string">&quot;)&quot;</span> ))&#123;</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek ( ).equals ( <span class="string">&quot;(&quot;</span> )) &#123;  <span class="comment">//s1.peek()查看栈顶内容，但不弹出;如果栈顶没有到达（就不停止，继续弹</span></span><br><span class="line">                    s2.add ( s1.pop ( ) );</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop ();<span class="comment">//将（弹出s1,消除小括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//若i优先级&lt;=栈顶运算符将s1栈顶的运算符弹出并加入到s2中，再次转到（4.1）与s1中新的栈顶运算符相比较；</span></span><br><span class="line">                <span class="comment">//缺少比较一个运算符优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size ()!=<span class="number">0</span>&amp;&amp; Operation.getValue ( s1.peek () )&gt;=Operation.getValue (  i))&#123;</span><br><span class="line">                    s2.add ( s1.pop ( ) );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//// 比栈顶运算符的高，也将运算符压入s1；</span></span><br><span class="line">                s1.push ( i );</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩下的运算符依次加入到s2中</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size ( ) != <span class="number">0</span>) &#123;</span><br><span class="line">            s2.add ( s1.pop() );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是存放到list中，正常输出即为后缀表达式</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个逆波兰表达式，依次将数据和运算符放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListStrings</span> <span class="params">( String suffixEpression )</span> &#123;</span><br><span class="line">        <span class="comment">//将suffixEpression分割</span></span><br><span class="line">        String[] spilt=suffixEpression.split ( <span class="string">&quot; &quot;</span> );  <span class="comment">//以空格来分割</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt; ( );</span><br><span class="line">        <span class="keyword">for</span> ( String element : spilt ) &#123;  <span class="comment">//将分割后的数依次循环</span></span><br><span class="line">            list.add( element );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">     * 2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">     * 3. 将5入栈；</span></span><br><span class="line"><span class="comment">     * 4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">     * 5. 将6入栈；</span></span><br><span class="line"><span class="comment">     * 6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果（下一个-顶部）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">calculate</span> <span class="params">( List&lt;String&gt; ls)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个栈</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt; ( );</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> ( String s : ls ) &#123;</span><br><span class="line">            <span class="comment">//这里使用正则表达式来取多位数</span></span><br><span class="line">            <span class="keyword">if</span> ( s.matches (<span class="string">&quot;\\d+&quot;</span>  )||s.matches ( <span class="string">&quot;\\d+.\\d+&quot;</span> ) )&#123;<span class="comment">//匹配多位数  s.matches来匹配数字“\\d+&quot;(+)表示一到多</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push ( s );</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//栈中弹出两个数，并运算，计算结果在入栈</span></span><br><span class="line">                <span class="type">float</span> num2=Double.valueOf ( stack.pop ( )).floatValue (); <span class="comment">//把整数或者小数的字符串转为float类型</span></span><br><span class="line">                <span class="type">float</span> num1=Double.valueOf ( stack.pop ( )).floatValue ();</span><br><span class="line">                <span class="type">double</span> res=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;+&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;-&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;*&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( s.equals ( <span class="string">&quot;/&quot;</span> ) ) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span> ( <span class="string">&quot;运算符完毕&quot;</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push (  <span class="string">&quot;&quot;</span>+res );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据为运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Double.valueOf ( stack.pop ( ) ).floatValue ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个Operation的类可以返回运算符优先级高低</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ADD=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> SUB=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> MUL=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> DIV=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法返回优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span> <span class="params">( String operation )</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV ;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println (<span class="string">&quot;运算符有误&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230126150326481.png" alt="image-20230126150326481"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/posts/43d00a99.html</url>
    <content><![CDATA[<span class="p center logo large">Select Sort</span>
<span class="p center small">排序算法——选择排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>

<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p><strong>图解分析图：</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230217212437015.png" alt="image-20230217212437015"></p>
<p><strong>思路：</strong></p>
<ol>
<li>选择排序一共有 数组大小 - 1 轮排序</li>
<li>每1轮排序，又是一个循环, 循环的规则(代码)<ol>
<li>先假定当前这个数是最小数</li>
<li>然后和后面的每个数进行比较，如果发现有比当前数更小的数，就重新确定最小数，并得到下标</li>
<li>当遍历到数组的最后时，就得到本轮最小数和下标</li>
<li>交换 </li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selecctSorting</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length - <span class="number">1</span> ; i++ ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[ minIndex ];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span> ; j &lt; arr.length ; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( min &gt; arr[ j ] ) &#123;</span><br><span class="line">                    min      = arr[ j ]; <span class="comment">//重置min</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( min != arr[ i ] ) &#123;  <span class="comment">//加一个判断，避免不必要的交换，浪费时间</span></span><br><span class="line">                <span class="comment">//将这个最小值放在此时的最前面</span></span><br><span class="line">                arr[ minIndex ] = arr[ i ];</span><br><span class="line">                arr[ i ]        = min;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println ( &quot;第&quot; + ( i + 1 ) + &quot;轮后 &quot; + Arrays.toString ( arr ) );</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlecctSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* int[] arr = &#123;101, 34, 119, 1&#125;;</span></span><br><span class="line"><span class="comment">        selecctSorting ( arr );</span></span><br><span class="line"><span class="comment">        System.out.println (&quot;排序后 &quot; + Arrays.toString ( arr ) );*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建80000个数据的数组</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000</span> ];</span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        System.out.println (<span class="string">&quot;选择排序所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序前时间是：&quot;</span>+date1String );</span><br><span class="line">        selecctSorting ( arr );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序后时间是：&quot;</span>+date2String );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selecctSorting</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length - <span class="number">1</span> ; i++ ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[ minIndex ];</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span> ; j &lt; arr.length ; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( min &gt; arr[ j ] ) &#123;</span><br><span class="line">                    min      = arr[ j ]; <span class="comment">//重置min</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( min != arr[ i ] ) &#123;  <span class="comment">//加一个判断，避免不必要的交换，浪费时间</span></span><br><span class="line">                <span class="comment">//将这个最小值放在此时的最前面</span></span><br><span class="line">                arr[ minIndex ] = arr[ i ];</span><br><span class="line">                arr[ i ]        = min;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println ( &quot;第&quot; + ( i + 1 ) + &quot;轮后 &quot; + Arrays.toString ( arr ) );</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++)&#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format(date1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230217221613345.png" alt="image-20230217221613345"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/posts/96555fb2.html</url>
    <content><![CDATA[<span class="p center logo large">Insert Sort</span>
<span class="p center small">排序算法——插入排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</p>
<h3 id="思路图解图"><a href="#思路图解图" class="headerlink" title="思路图解图"></a>思路图解图</h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230218113311086.png" alt="image-20230218113311086"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSorting</span><span class="params">(<span class="type">int</span> [] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//定义待插入的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> arr[ i ];</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给insetValue找到插入的位置</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertValue &lt; arr[ insertIndex ]) &#123;</span><br><span class="line">                <span class="comment">//insertIndex &gt;= 0 保证不越界，</span></span><br><span class="line">                <span class="comment">// insertValue &lt; arr[ insertIndex ]判断待插入的数是否找到合适位置</span></span><br><span class="line">                <span class="comment">//满足，则进行交换</span></span><br><span class="line">                arr[ insertIndex + <span class="number">1</span> ] = arr[ insertIndex ];</span><br><span class="line">                insertIndex--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当while退出说明找到合适的位置</span></span><br><span class="line">            <span class="keyword">if</span> ( insertIndex!=i-<span class="number">1</span> ) &#123;</span><br><span class="line">                arr[ insertIndex + <span class="number">1</span> ] = insertValue;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println ( &quot;第&quot;+i+&quot;轮结果&quot;+Arrays.toString ( arr ) );</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( Arrays.toString ( arr ) );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;101, 34, 119, 1&#125;;</span></span><br><span class="line"><span class="comment">//        insertSorting ( arr );</span></span><br><span class="line">        <span class="comment">//创建80000个数据的数组</span></span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000</span> ];</span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        System.out.println (<span class="string">&quot;插入排序所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序前时间是：&quot;</span>+date1String );</span><br><span class="line">        insertSorting ( arr );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println (<span class="string">&quot;排序后时间是：&quot;</span>+date2String );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSorting</span><span class="params">(<span class="type">int</span> [] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//定义待插入的数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertValue</span> <span class="operator">=</span> arr[ i ];</span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给insetValue找到插入的位置</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertValue &lt; arr[ insertIndex ]) &#123;</span><br><span class="line">                <span class="comment">//insertIndex &gt;= 0 保证不越界，</span></span><br><span class="line">                <span class="comment">// insertValue &lt; arr[ insertIndex ]判断待插入的数是否找到合适位置</span></span><br><span class="line">                <span class="comment">//满足，则进行交换</span></span><br><span class="line">                arr[ insertIndex + <span class="number">1</span> ] = arr[ insertIndex ];</span><br><span class="line">                insertIndex--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当while退出说明找到合适的位置</span></span><br><span class="line">            <span class="keyword">if</span> ( insertIndex!=i-<span class="number">1</span> ) &#123;</span><br><span class="line">                arr[ insertIndex + <span class="number">1</span> ] = insertValue;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println ( &quot;第&quot;+i+&quot;轮结果&quot;+Arrays.toString ( arr ) );</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println ( Arrays.toString ( arr ) );</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length;i++)&#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format(date1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230218125144211.png" alt="image-20230218125144211"></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：</p>
<blockquote>
<p>{2,3,4,5,6,6}<br>{2,3,4,5,5,6}<br>{2,3,4,4,5,6}<br>{2,3,3,4,5,6}<br>{2,2,3,4,5,6}<br>{1,2,3,4,5,6}</p>
</blockquote>
<p><strong>结论: 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/posts/6367b42a.html</url>
    <content><![CDATA[<span class="p center logo large">Radix Sort</span>
<span class="p center small">排序算法——基数排序</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>


<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p><code>基数排序（radix sort）</code>属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它<strong>是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</strong></p>
</li>
<li><p>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</p>
</li>
<li>基数排序(Radix Sort)是桶排序的扩展</li>
</ol>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<h4 id="思路图解"><a href="#思路图解" class="headerlink" title="思路图解"></a>思路图解</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230226151606841.png" alt="image-20230226151606841"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>ps:不支持负数</p>
<h3 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h3><p>基数排序是根据元素的某位数的值进行划分，将对应元素划分到桶里，然后在存入原数组，不断循环以上做法，循环次数是最大元素的位数，当循环完后，顺序也就出来了。从代码上看，也会发现该算法是明显的空间换时间，但明显会感觉到它的循环次数少比较也只在判断时比较，因此达到时间很短。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先找最大值</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream ( arr ).max ( ).getAsInt ( );</span><br><span class="line">    <span class="comment">//得到最大数是几位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> ( max + <span class="string">&quot;&quot;</span> ).length ( );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个二维数据，表示10个桶，每个桶就是一维数组</span></span><br><span class="line">    <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">10</span> ][ arr.length ];</span><br><span class="line">    <span class="comment">//为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">    <span class="comment">//比如bucketindex[0],就记录的是bucket[0]桶的放入数据个数</span></span><br><span class="line">    <span class="type">int</span>[] bucketIndex = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">10</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用循环来控制每一轮</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,n=<span class="number">1</span>; i &lt; maxLength; i++ ,n*=<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length ; j++ ) &#123;</span><br><span class="line">            <span class="comment">//取出每个元素对应位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[ j ] /n % <span class="number">10</span>;  <span class="comment">//</span></span><br><span class="line">            <span class="comment">//放入对应的桶</span></span><br><span class="line">            bucket[ digitOfElement ][ bucketIndex[ digitOfElement ] ] = arr[ j ];  <span class="comment">//根据元素的个位数，放到对应的桶中，用bucketIndex[ digitOfElement ]的方式记录在桶中存放的位置</span></span><br><span class="line">            bucketIndex[ digitOfElement ]++; <span class="comment">//自加加使指针下标往后移动，来等待下一个存储</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照加入元素的先后顺序取出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一个桶，并把桶中数据，放入原数组</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; bucket.length ; x++ ) &#123;</span><br><span class="line">            <span class="comment">//如果桶里有数据我们才放入</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span> ; y &lt; bucketIndex[ x ] ; y++ ) &#123;</span><br><span class="line">                arr[ index ] = bucket[ x ][ y ];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非常重要，会影响后面后面轮数的指针下标</span></span><br><span class="line">            bucketIndex[ x ] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( <span class="string">&quot;第&quot;</span> + ( i + <span class="number">1</span> ) + <span class="string">&quot;轮结果&quot;</span> + Arrays.toString ( arr ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSorting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;53, 3, 542, 748, 14, 214&#125;;</span></span><br><span class="line"><span class="comment">//        radixSort ( arr );</span></span><br><span class="line">        <span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">80000000</span> ];</span><br><span class="line">        randomArr ( arr );</span><br><span class="line">        System.out.println ( <span class="string">&quot;基数排序8000万数据所用时间&quot;</span> );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println ( <span class="string">&quot;排序前时间是：&quot;</span> + date1String );</span><br><span class="line">        radixSort ( arr );</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2String</span> <span class="operator">=</span> Date ( );</span><br><span class="line">        System.out.println ( <span class="string">&quot;排序后时间是：&quot;</span> + date2String );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首先找最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Arrays.stream ( arr ).max ( ).getAsInt ( );</span><br><span class="line"><span class="comment">//        int max = arr[ 0 ];</span></span><br><span class="line"><span class="comment">//        for ( int i=0;i&lt;arr.length;i++ ) &#123;</span></span><br><span class="line"><span class="comment">//            if ( arr[ i ] &gt; max ) &#123;</span></span><br><span class="line"><span class="comment">//                max = arr[ i ];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//得到最大数是几位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> ( max + <span class="string">&quot;&quot;</span> ).length ( );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数据，表示10个桶，每个桶就是一维数组</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">10</span> ][ arr.length ];</span><br><span class="line">        <span class="comment">//为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//比如bucketindex[0],就记录的是bucket[0]桶的放入数据个数</span></span><br><span class="line">        <span class="type">int</span>[] bucketIndex = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">10</span> ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里使用循环来控制每一轮</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,n=<span class="number">1</span>; i &lt; maxLength; i++ ,n*=<span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; arr.length ; j++ ) &#123;</span><br><span class="line">                <span class="comment">//取出每个元素对应位的值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[ j ] /n % <span class="number">10</span>;  <span class="comment">//</span></span><br><span class="line">                <span class="comment">//放入对应的桶</span></span><br><span class="line">                bucket[ digitOfElement ][ bucketIndex[ digitOfElement ] ] = arr[ j ];  <span class="comment">//根据元素的个位数，放到对应的桶中，用bucketIndex[ digitOfElement ]的方式记录在桶中存放的位置</span></span><br><span class="line">                bucketIndex[ digitOfElement ]++; <span class="comment">//自加加使指针下标往后移动，来等待下一个存储</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照加入元素的先后顺序取出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历每一个桶，并把桶中数据，放入原数组</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; bucket.length ; x++ ) &#123;</span><br><span class="line">                <span class="comment">//如果桶里有数据我们才放入</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span> ; y &lt; bucketIndex[ x ] ; y++ ) &#123;</span><br><span class="line">                    arr[ index ] = bucket[ x ][ y ];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//非常重要，会影响后面后面轮数的指针下标</span></span><br><span class="line">                bucketIndex[ x ] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println ( &quot;第&quot; + ( i + 1 ) + &quot;轮结果&quot; + Arrays.toString ( arr ) );</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*//第一轮排序（针对元素个数进行排序）</span></span><br><span class="line"><span class="comment">        for ( int j = 0 ; j &lt; arr.length ; j++ ) &#123;</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[ j ] % 10;  //元素的个位数</span></span><br><span class="line"><span class="comment">            //放入对应的桶</span></span><br><span class="line"><span class="comment">            bucket[ digitOfElement ][ bucketIndex[ digitOfElement ] ] = arr[ j ];  //根据元素的个位数，放到对应的桶中，用bucketIndex[ digitOfElement ]的方式记录在桶中存放的位置</span></span><br><span class="line"><span class="comment">            bucketIndex[ digitOfElement ]++; //自加加使指针下标往后移动，来等待下一个存储</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //按照加入元素的先后顺序取出</span></span><br><span class="line"><span class="comment">        int index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并把桶中数据，放入原数组</span></span><br><span class="line"><span class="comment">        for ( int x = 0 ; x &lt; bucket.length ; x++ ) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶里有数据我们才放入</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            for ( int y = 0 ; y &lt; bucketIndex[ x ] ; y++ ) &#123;</span></span><br><span class="line"><span class="comment">                arr[ index ] = bucket[ x ][ y ];</span></span><br><span class="line"><span class="comment">                index++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //非常重要，会影响后面后面轮数的指针下标</span></span><br><span class="line"><span class="comment">            bucketIndex[ x ] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println ( Arrays.toString( arr));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //第二轮排序（针对元素百位数进行排序）</span></span><br><span class="line"><span class="comment">        for ( int j = 0 ; j &lt; arr.length ; j++ ) &#123;</span></span><br><span class="line"><span class="comment">            int digitOfElement = arr[ j ] /10 % 10;  //元素的百位数</span></span><br><span class="line"><span class="comment">            //放入对应的桶</span></span><br><span class="line"><span class="comment">            bucket[ digitOfElement ][ bucketIndex[ digitOfElement ] ] = arr[ j ];  //根据元素的个位数，放到对应的桶中，用bucketIndex[ digitOfElement ]的方式记录在桶中存放的位置</span></span><br><span class="line"><span class="comment">            bucketIndex[ digitOfElement ]++; //自加加使指针下标往后移动，来等待下一个存储</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        //按照加入元素的先后顺序取出</span></span><br><span class="line"><span class="comment">        index = 0;</span></span><br><span class="line"><span class="comment">        //遍历每一个桶，并把桶中数据，放入原数组</span></span><br><span class="line"><span class="comment">        for ( int x = 0 ; x &lt; bucket.length ; x++ ) &#123;</span></span><br><span class="line"><span class="comment">            //如果桶里有数据我们才放入</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            for ( int y = 0 ; y &lt; bucketIndex[ x ] ; y++ ) &#123;</span></span><br><span class="line"><span class="comment">                arr[ index ] = bucket[ x ][ y ];</span></span><br><span class="line"><span class="comment">                index++;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            //非常重要，会影响后面后面轮数的指针下标</span></span><br><span class="line"><span class="comment">            bucketIndex[ x ] = 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        System.out.println ( Arrays.toString( arr));*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">randomArr</span> <span class="params">( <span class="type">int</span>[] arr )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++ ) &#123;</span><br><span class="line">            arr[ i ] = (<span class="type">int</span>) ( Math.random ( ) * <span class="number">8000000</span> );  <span class="comment">//会生成【0，8000000）直接的数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将此时调用函数的时间格式化打出来</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 年-月-日 时-分秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">Date</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span> ( );  <span class="comment">//调函数的当前时间</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleFormatter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> ( <span class="string">&quot;HH:mm:ss&quot;</span> );<span class="comment">//格式化</span></span><br><span class="line">        <span class="keyword">return</span> simpleFormatter.format ( date1 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/2/image-20230226202544849.png" alt="image-20230226202544849"></p>
<p>PS:上面我们测试8000万个数据来进行测试，就数据产生的空间，我们大致计算一 下，</p>
<p>​                        <strong>80000000 X 11 X 4 / 1024 / 1024 / 1024=3.3G</strong></p>
<p>由此可知，<strong>虽然它的效率高，但它所产生的内存也十分的巨大</strong>。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Sort Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/posts/c6654282.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">初始递归</span><br><span class="p center small">递归——基本内容</span></p>
<h3 id="递归应用场景"><a href="#递归应用场景" class="headerlink" title="递归应用场景"></a>递归应用场景</h3><p><strong>迷宫问题(回溯)， 递归(Recursion)</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230126160647622.png" alt="image-20230126160647622" style="zoom:67%;"></p>
<h3 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h3><blockquote>
<p>递归就是方法自己调用自己,每次调用时传入不同的变量。</p>
<p><strong>递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</strong></p>
</blockquote>
<h3 id="递归调用机制"><a href="#递归调用机制" class="headerlink" title="递归调用机制"></a>递归调用机制</h3><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230126161223092.png" alt="image-20230126161223092" style="zoom: 67%;"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//通过打印问题，回顾调用机制</span></span><br><span class="line">         test ( <span class="number">4</span> );</span><br><span class="line">         <span class="comment">//阶乘问题</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> factorial ( <span class="number">5</span> );</span><br><span class="line">        System.out.println (<span class="string">&quot;res=&quot;</span>+res );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;n=&quot;</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阶乘问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230126161453910.png" alt="image-20230126161453910"></p>
<h3 id="递归解决的问题"><a href="#递归解决的问题" class="headerlink" title="递归解决的问题"></a>递归解决的问题</h3><ol>
<li>各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)</li>
<li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.</li>
<li>将用栈解决的问题—&gt;第归代码比较简洁</li>
</ol>
<h3 id="递归规则"><a href="#递归规则" class="headerlink" title="递归规则"></a>递归规则</h3><ol>
<li><strong>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</strong></li>
<li><strong>方法的局部变量是独立的，不会相互影响, 比如n变量</strong></li>
<li><strong>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</strong></li>
<li><strong>递归必须向<emp>退出递归的条件逼近</emp>，否则就是无限递归,出现StackOverflowError，死龟了)</strong></li>
<li><strong>当一个方法执行完毕，或者遇到return，就会返回，<emp>遵守谁调用，就将结果返回给谁</emp>，同时当方法执行完毕或者返回时，该方法也就执行完毕。</strong></li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>单向环形列表的应用场景</title>
    <url>/posts/3569883e.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">约瑟夫问题</span><br><span class="p center small">数据结构——简单应用单链表</span></p>
<h2 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h2><p>Josephu 问题为: 设编号为1, 2, .. n的n个人围坐一圈，约定编号为k (1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>​    <code>**提示**</code>: 用一个不带头结点的循环链表来处理Josephu问题: 先构成一个有 n个结点的单循环链表，然后由k结<br>点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直<br>到最后一个结点从链表中删除算法结束。</p>
<hr>
<h3 id="单向环形链表"><a href="#单向环形链表" class="headerlink" title="单向环形链表"></a>单向环形链表</h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230116230614412.png" alt="image-20230116230614412" style="zoom:67%;"></p>
<h3 id="约瑟夫问题分析图"><a href="#约瑟夫问题分析图" class="headerlink" title="约瑟夫问题分析图"></a>约瑟夫问题分析图</h3><p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230116230924680.png" alt="image-20230116230924680" style="zoom: 67%;"></p>
<h3 id="代码实现分析-："><a href="#代码实现分析-：" class="headerlink" title="代码实现分析 ："></a>代码实现<strong>分析</strong> ：</h3><ul>
<li><p>先创建一个单项环形链表</p>
<ol>
<li><p>先创建第一个节点，让first指向该节点，并形成环形</p>
</li>
<li><p>后边当我们每创建一个新的节点，就把该节点，加到已有的环形链表中即可</p>
</li>
</ol>
</li>
<li><p>遍历环形链表</p>
<ol>
<li><p>先让一个辅助指针（temp），指向first</p>
</li>
<li><p>然后通过一个while循环遍历该链表即可    ( <wavy>temp.next=first</wavy>)遍历结束</p>
<div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230117170218531.png" alt="image-20230117170218531" style="zoom:67%;"></p>
</div></div>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>生成小孩出圈的顺序</p>
<ol>
<li><p>先创建一个辅助指针（helper），让它指向环形链表的最后一个</p>
</li>
<li><p>报数前，先让first和helper移动到startNo</p>
</li>
<li><p>当小孩报数时，让first与helper同时移动m-1次</p>
</li>
<li><p>这时first指向的小孩出圈</p>
 <wavy>first=first.next</wavy>
 <wavy>helper.next=first</wavy>
</li>
<li><p>此时原来first指向的节点就会被回收</p>
<div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230117170339763.png" alt="image-20230117170339763" style="zoom:67%;"></p>
</div></div>
</li>
</ol>
</li>
</ul>
<h3 id="创建节点的代码"><a href="#创建节点的代码" class="headerlink" title="创建节点的代码"></a>创建节点的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个Child类表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> Child next;  <span class="comment">//指向下一个节点，默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span> <span class="params">( <span class="type">int</span> no )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span> <span class="params">( <span class="type">int</span> no )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Child <span class="title function_">getNext</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span> <span class="params">( Child next )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建环形链表的代码"><a href="#创建环形链表的代码" class="headerlink" title="创建环形链表的代码"></a>创建环形链表的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CireSingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Child</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span> ( -<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建一个环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CreatChildList</span> <span class="params">( <span class="type">int</span> nums )</span> &#123;</span><br><span class="line">        <span class="comment">//对nums 进行数据校验</span></span><br><span class="line">        <span class="keyword">if</span> ( nums &lt; <span class="number">1</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;nums的值不正确&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建环形链表</span></span><br><span class="line">        <span class="type">Child</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//辅助指针，帮助构建环形指针</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= nums ; i++ ) &#123;</span><br><span class="line">            <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">            <span class="type">Child</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span> ( i );</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="number">1</span> ) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext ( first );</span><br><span class="line">                temp = first;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.setNext ( boy );<span class="comment">//把之前最的后辅助节点的next指向新加的</span></span><br><span class="line">                boy.setNext ( first );<span class="comment">//此时处在最后的节点的next指向first</span></span><br><span class="line">                temp = boy;  <span class="comment">//辅助节点往后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( first == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表为空，没有任何小孩\n&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，所以我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        <span class="type">Child</span> <span class="variable">temp</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  <span class="comment">//满足条件说明已经是最后一个，遍历完毕</span></span><br><span class="line">            System.out.printf ( <span class="string">&quot;小孩的编号为%d\n&quot;</span>, temp.getNo ( ) );</span><br><span class="line">            <span class="keyword">if</span> ( temp.getNext ( ) == first ) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.getNext ( );<span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小孩出圈顺序代码"><a href="#小孩出圈顺序代码" class="headerlink" title="小孩出圈顺序代码"></a>小孩出圈顺序代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小孩出圈</span></span><br><span class="line"><span class="comment">//根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo  开始节点  ，表示从第几个小孩开始</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum 每次数几下（m）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums     表示最初有几个人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span> <span class="params">( <span class="type">int</span> startNo, <span class="type">int</span> countNum, <span class="type">int</span> nums )</span> &#123;</span><br><span class="line">    <span class="comment">//先对数据进行校验</span></span><br><span class="line">    <span class="keyword">if</span> ( first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums ) &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;参数输入有误，请从新输入&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先创建一个辅助指针（helper），让它指向环形链表的最后一个</span></span><br><span class="line">    <span class="type">Child</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( helper.getNext ( ) == first ) &#123;  <span class="comment">//说明helper指向最后一个节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper = helper.getNext ( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先将first移动到startNo节点</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; startNo - <span class="number">1</span> ; j++ ) &#123;</span><br><span class="line">        first=first.getNext ( );</span><br><span class="line">        helper = helper.getNext ( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当小孩报数时，让first与helper同时移动m-1次,然后出圈</span></span><br><span class="line">    <span class="comment">//这里是一个循环操作，直到圈中只有一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (helper!=first) &#123;   <span class="comment">//helper==first(helper.getnext()==helper)说明圈中只有一个节点</span></span><br><span class="line">        <span class="comment">//让first与helper同时移动countNum-1次</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; countNum - <span class="number">1</span> ; j++ ) &#123;</span><br><span class="line">            first=first.getNext ( );</span><br><span class="line">            helper = helper.getNext ( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时first指向的节点是要出圈的小孩</span></span><br><span class="line">        System.out.printf ( <span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo ( ) );</span><br><span class="line">        <span class="comment">//将此时first指向的小孩弄出圈</span></span><br><span class="line">        first = first.getNext ( );</span><br><span class="line">        helper.setNext ( first );</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf ( <span class="string">&quot;最后留在圈中的小孩编号%d\n&quot;</span>,first.getNo () );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title>SingleLinkList</title>
    <url>/posts/1faa2557.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">单链表基础功能</span><br><span class="p center small">数据结构——初始单链表</span></p>
<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义SingleLinkedList管理英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点,头节点不要动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单链表中</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时，</span></span><br><span class="line"><span class="comment">//        1.找到链表最后一个节点</span></span><br><span class="line"><span class="comment">//        2.将最后这个节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">( HeroNode heroNode )</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while时，temp就指向最后</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式在添加英雄，将英雄添加到指定位置</span></span><br><span class="line">    <span class="comment">//如果有这个排名提示添加失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addpro</span> <span class="params">( HeroNode heroNode )</span> &#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此仍需要辅助节点来帮助我们添加</span></span><br><span class="line"><span class="comment">//        因为单链表,因此我们找的temp是位于添加位置的前一个节点，否则添加不进去</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;<span class="comment">//说明temp已经在链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next.no &gt; heroNode.no ) &#123;<span class="comment">//位置找到，就在temp后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( temp.next.no == heroNode.no ) &#123;<span class="comment">//要添加的heronode依然存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//后移遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;<span class="comment">//编号存在</span></span><br><span class="line">            System.out.printf ( <span class="string">&quot;准备插入的英雄编号%d,已经存在,不能加入\n&quot;</span>, heroNode.no );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入到正确位置。temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next     = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改节点的信息，根据no来修改，name，nickname</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updata</span> <span class="params">( HeroNode newHeroNode )</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表为空&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//链表已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.no == newHeroNode.no ) &#123;</span><br><span class="line">                <span class="comment">//找到节点</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断节点是否可以找到</span></span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            temp.name     = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//没有找到</span></span><br><span class="line">            System.out.printf ( <span class="string">&quot;没有找到编号%d的节点，无法修改\n&quot;</span>, newHeroNode.no );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//就是将要删除的前一个节点的next==要删除的next</span></span><br><span class="line"><span class="comment">//    temp.next=temp.next.next;</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1.head不能动，因此我们需要一个temp辅助接点找到待删除的前一个节点</span></span><br><span class="line">    <span class="comment">//2.说明我们在比较时，temp.next.no=目标节点的no</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span> <span class="params">( <span class="type">int</span> no )</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next.no == no ) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf ( <span class="string">&quot;列表中的no值无%d,无法删除\n&quot;</span>, no );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span> <span class="params">( <span class="type">int</span> no )</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.no == no ) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;你查找的信息如下：&quot;</span> );</span><br><span class="line">            System.out.println ( temp );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf ( <span class="string">&quot;列表中的no值无%d,无法查到\n&quot;</span>, no );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表为空&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> ( temp == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println ( temp );</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个heroNode,每个HeroNode 对象是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span> <span class="params">( <span class="type">int</span> no, String name, String nickname )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no       = no;</span><br><span class="line">        <span class="built_in">this</span>.name     = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//进行一个测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">1</span>, <span class="string">&quot;松江&quot;</span>, <span class="string">&quot;及时雨&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span> ( );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入</span></span><br><span class="line"><span class="comment">//        singleLinkedList1.add ( hero1 );</span></span><br><span class="line"><span class="comment">//        singleLinkedList1.add ( hero2 );</span></span><br><span class="line"><span class="comment">//        singleLinkedList1.add ( hero3 );</span></span><br><span class="line"><span class="comment">//        singleLinkedList1.add ( hero4 );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println (&quot;增删改查&quot; );</span></span><br><span class="line">        <span class="comment">//添加</span></span><br><span class="line">        singleLinkedList1.addpro ( hero1 );</span><br><span class="line">        singleLinkedList1.addpro ( hero3 );</span><br><span class="line">        singleLinkedList1.addpro ( hero2 );</span><br><span class="line">        singleLinkedList1.addpro ( hero2 );</span><br><span class="line">        singleLinkedList1.addpro ( hero4 );</span><br><span class="line"></span><br><span class="line">        singleLinkedList1.list ( );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span> );</span><br><span class="line">        singleLinkedList1.updata ( newHeroNode );</span><br><span class="line">        <span class="comment">//显示列表</span></span><br><span class="line">        singleLinkedList1.list ( );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        singleLinkedList1.find ( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        singleLinkedList1.delete ( <span class="number">1</span> );</span><br><span class="line">        singleLinkedList1.delete ( <span class="number">4</span> );</span><br><span class="line">        System.out.println (<span class="string">&quot;删除完后的列表&quot;</span> );</span><br><span class="line">        singleLinkedList1.list ( );</span><br><span class="line">        System.out.printf (<span class="string">&quot;链表中有效节点为%d\n&quot;</span>,getLength ( singleLinkedList1.getHead()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单链表题目练习"><a href="#单链表题目练习" class="headerlink" title="单链表题目练习"></a>单链表题目练习</h2><h3 id="求链表的有效节点个数"><a href="#求链表的有效节点个数" class="headerlink" title="求链表的有效节点个数"></a>求链表的有效节点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法：获取到单链表的有效节点个数（如果是带头节点的列表，需要去掉头）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值为有效值的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span> <span class="params">( HeroNode head )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;<span class="comment">//空列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义一个辅助节点,这里我们没有统计头节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        temp = temp.next;<span class="comment">//遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找单链表的倒数第K个节点"><a href="#查找单链表的倒数第K个节点" class="headerlink" title="查找单链表的倒数第K个节点"></a>查找单链表的倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找单链表的倒数第K个节点</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1.编写一个方法，接收一个head节点，同时接收一个index(index为查找倒数第几个的值)</span></span><br><span class="line"><span class="comment">//2.先把链表从头到位遍历，先得到总的长度</span></span><br><span class="line"><span class="comment">//3.然后遍历从头到（size-index）个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findIndex</span> <span class="params">( HeroNode head, <span class="type">int</span> index )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;列表为空&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength ( head );</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="keyword">if</span> ( num &lt; <span class="number">0</span> || num &gt; size ) &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;index值输入错误&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; num) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println ( temp );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表进行反转"><a href="#单链表进行反转" class="headerlink" title="单链表进行反转"></a>单链表进行反转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//单链表进行反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span> <span class="params">( HeroNode head )</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前列表为空，或者只有一个节点，就不去反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个辅助指针，帮助我们遍历原来的链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//指向当前节点的下一个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line">        <span class="comment">//遍历原来的链表，</span></span><br><span class="line">        <span class="comment">//并且每遍历一个节点，就将其取出，并放到新的列表reverseHead的最前端</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让辅助链表替原链表遍历，让节点的下一个等于新链表head.next</span></span><br><span class="line">            next      = temp.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            temp.next = reverseHead.next;  <span class="comment">//解决后连问题  把原链表的节点的next数据清除，达到一次插入一个节点</span></span><br><span class="line"><span class="comment">//            System.out.println (reverseHead.next );</span></span><br><span class="line">            reverseHead.next = temp;  <span class="comment">//解决头部与遍历节点的连接</span></span><br><span class="line">            temp             = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next指向reverseHead.next，实现单链表反转</span></span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="逆序打印单链表"><a href="#逆序打印单链表" class="headerlink" title="逆序打印单链表"></a>逆序打印单链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从尾到头打印单链表（逆序打印单链表）</span></span><br><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入栈中，再利用栈的先进后出的特点，实现逆序打印</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span> <span class="params">( HeroNode head )</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;空链表无打印&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个栈，将各个节点压入栈中</span></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt; ( );</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="comment">//将链表的所有结点压入站点</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push ( temp );  <span class="comment">//压入</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//压入栈以后，将栈中的节点进行打印</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size ( ) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println ( stack.pop ( ) );  <span class="comment">//弹出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个有序的单链表，合并之后依然有序"><a href="#合并两个有序的单链表，合并之后依然有序" class="headerlink" title="合并两个有序的单链表，合并之后依然有序"></a>合并两个有序的单链表，合并之后依然有序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的单链表，合并之后依然有序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title function_">combineSingleLink</span> <span class="params">( SingleLinkedList link1, SingleLinkedList link2 )</span> &#123;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">head1</span> <span class="operator">=</span> link1.getHead ( );</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">head2</span> <span class="operator">=</span> link2.getHead ( );</span><br><span class="line">    <span class="keyword">if</span> ( head1.next == <span class="literal">null</span> &amp;&amp; head2.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( head1.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;链表一为空&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> link2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( head2.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">        System.out.println ( <span class="string">&quot;链表二为空&quot;</span> );</span><br><span class="line">        <span class="keyword">return</span> link1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp1</span> <span class="operator">=</span> head1.next;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp2</span> <span class="operator">=</span> head2.next;</span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">link</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span> ( );</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> link.getHead ( );</span><br><span class="line">    temp.next = temp1;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp2.no &lt;= temp.next.no ) &#123;</span><br><span class="line">            next       = temp2.next;   <span class="comment">//此部分和反转链表一样，这个要加在最后面，而反转链表反之</span></span><br><span class="line">            temp2.next = temp.next;</span><br><span class="line">            temp.next  = temp2;</span><br><span class="line">            temp2      = next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//进行一个测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">2</span>, <span class="string">&quot;松江&quot;</span>, <span class="string">&quot;及时雨&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">5</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">6</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">1</span>, <span class="string">&quot;松江&quot;</span>, <span class="string">&quot;及时雨&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">4</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">8</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">9</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span> ( );</span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span> ( );</span><br><span class="line"></span><br><span class="line">		<span class="comment">//填充链表1和链表2</span></span><br><span class="line">        singleLinkedList1.addpro ( hero1 );</span><br><span class="line">        singleLinkedList1.addpro ( hero3 );</span><br><span class="line">        singleLinkedList1.addpro ( hero2 );</span><br><span class="line">        singleLinkedList1.addpro ( hero4 );</span><br><span class="line">        singleLinkedList2.addpro ( hero5 );</span><br><span class="line">        singleLinkedList2.addpro ( hero6 );</span><br><span class="line">        singleLinkedList2.addpro ( hero7 );</span><br><span class="line">        singleLinkedList2.addpro ( hero8 );</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//组合后的链表</span></span><br><span class="line">        combineSingleLink ( singleLinkedList1, singleLinkedList2 ).list ( );</span><br><span class="line"></span><br><span class="line">        System.out.printf ( <span class="string">&quot;链表中有效节点为%d\n&quot;</span>, getLength ( singleLinkedList1.getHead ( ) ) );</span><br><span class="line">        <span class="comment">//逆序打印</span></span><br><span class="line">        System.out.println ( <span class="string">&quot;测试逆序打印单链表,没有改变本身结构&quot;</span> );</span><br><span class="line">        reversePrint ( singleLinkedList1.getHead ( ) );</span><br><span class="line">        <span class="comment">//查找倒数第二个值</span></span><br><span class="line">        System.out.println ( <span class="string">&quot;查找值&quot;</span> );</span><br><span class="line">        findIndex ( singleLinkedList1.getHead ( ), <span class="number">2</span> );</span><br><span class="line">        System.out.println ( <span class="string">&quot;修改之后的列表&quot;</span> );</span><br><span class="line">        singleLinkedList1.list ( );</span><br><span class="line">        <span class="comment">//反转单链表</span></span><br><span class="line">        System.out.println ( <span class="string">&quot;原来链表&quot;</span> );</span><br><span class="line">        singleLinkedList1.list ( );</span><br><span class="line"></span><br><span class="line">        System.out.println ( <span class="string">&quot;反转后的链表&quot;</span> );</span><br><span class="line">        reverseLinkedList ( singleLinkedList1.getHead ( ) );</span><br><span class="line">        singleLinkedList1.list ( );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法：获取到单链表的有效节点个数（如果是带头节点的列表，需要去掉头）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值为有效值的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span> <span class="params">( HeroNode head )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;<span class="comment">//空列表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义一个辅助节点,这里我们没有统计头节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            temp = temp.next;<span class="comment">//遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找单链表的倒数第K个节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.编写一个方法，接收一个head节点，同时接收一个index(index为查找倒数第几个的值)</span></span><br><span class="line">    <span class="comment">//2.先把链表从头到位遍历，先得到总的长度</span></span><br><span class="line">    <span class="comment">//3.然后遍历从头到（size-index）个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findIndex</span> <span class="params">( HeroNode head, <span class="type">int</span> index )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;列表为空&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength ( head );</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> ( num &lt; <span class="number">0</span> || num &gt; size ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;index值输入错误&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; num) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( temp );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单链表进行反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedList</span> <span class="params">( HeroNode head )</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前列表为空，或者只有一个节点，就不去反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个辅助指针，帮助我们遍历原来的链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//指向当前节点的下一个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span> ( <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line">        <span class="comment">//遍历原来的链表，</span></span><br><span class="line">        <span class="comment">//并且每遍历一个节点，就将其取出，并放到新的列表reverseHead的最前端</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让辅助链表替原链表遍历，让节点的下一个等于新链表head.next</span></span><br><span class="line">            next      = temp.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            temp.next = reverseHead.next;  <span class="comment">//解决后连问题  把原链表的节点的next数据清除，达到一次插入一个节点</span></span><br><span class="line"><span class="comment">//            System.out.println (reverseHead.next );</span></span><br><span class="line">            reverseHead.next = temp;  <span class="comment">//解决头部与遍历节点的连接</span></span><br><span class="line">            temp             = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next指向reverseHead.next，实现单链表反转</span></span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从尾到头打印单链表（逆序打印单链表）</span></span><br><span class="line">    <span class="comment">//可以利用栈这个数据结构，将各个节点压入栈中，再利用栈的先进后出的特点，实现逆序打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span> <span class="params">( HeroNode head )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;空链表无打印&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个栈，将各个节点压入栈中</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt; ( );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//将链表的所有结点压入站点</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push ( temp );  <span class="comment">//压入</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压入栈以后，将栈中的节点进行打印</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size ( ) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println ( stack.pop ( ) );  <span class="comment">//弹出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序的单链表，合并之后依然有序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title function_">combineSingleLink</span> <span class="params">( SingleLinkedList link1, SingleLinkedList link2 )</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">head1</span> <span class="operator">=</span> link1.getHead ( );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">head2</span> <span class="operator">=</span> link2.getHead ( );</span><br><span class="line">        <span class="keyword">if</span> ( head1.next == <span class="literal">null</span> &amp;&amp; head2.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( head1.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表一为空&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span> link2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( head2.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表二为空&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span> link1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp1</span> <span class="operator">=</span> head1.next;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp2</span> <span class="operator">=</span> head2.next;</span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">link</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span> ( );</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> link.getHead ( );</span><br><span class="line">        temp.next = temp1;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp2.no &lt;= temp.next.no ) &#123;</span><br><span class="line">                next       = temp2.next;</span><br><span class="line">                temp2.next = temp.next;</span><br><span class="line">                temp.next  = temp2;</span><br><span class="line">                temp2      = next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> link;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style></style>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title>递归-八皇后</title>
    <url>/posts/66bc7234.html</url>
    <content><![CDATA[<span class="p center logo large">八皇后问题</span>
<span class="p center small">递归——回溯算法解决八皇后问题</span>
<script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script>


<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</strong></p>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 </li>
</ol>
<p>说明：用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="tip warning faa-horizontal animated faa-fast"><p>warning:在judge方法中特别注意<emp>array[ i ] == array[ n ] || Math.abs ( n - i ) == Math.abs ( array[ n ] - array[ i ] )</emp><br>            //说明<br>            //1.array[ i ] == array[ n ] 表示判断第n个皇后和前面的n-1个皇后是否在同一列，<br>            //2.Math.abs ( n - i ) == Math.abs ( array[ n ] - array[ i ] )  表示判断第n个皇后和前面的n-1个皇后是否在同一斜线<br>            //3.因为我们的下标表示行-1所以下标不断递增所以不用判断是否在同一行</p>
<pre><code>        //因为我们之前规定，一维数组下标表示行-1，下标对应的值表示在该行上第几列，
        //举例1.第一行第一个为皇后1 arr[0]=0  第二个皇后第二行第二列arr[1]=1
        //Math.abs ( 1 - 0 ) == Math.abs ( array[ 1 ] - array[ 0 ] )=1
        //第三行第二列arr[2]=1   第6行第5列arr[5]=4
        //Math.abs ( 5 - 2 ) == Math.abs ( array[ 5 ] - array[ 2 ] )=3
        //此时画图他们确实为一条斜线
</code></pre></div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queen8</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义一个数组array,保存皇后放置位置的结果，比如arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[ max ];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//表示有多少种成功结果</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//表示不断回溯判断，判断了多少次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="type">Queen8</span> <span class="variable">queen8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queen8</span> ( );</span><br><span class="line">        queen8.check (<span class="number">0</span>  );</span><br><span class="line">        System.out.printf ( <span class="string">&quot;一共有%d种解法，不断回溯，判断是否冲突%d次&quot;</span>, count, num );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放置第n个皇后</span></span><br><span class="line">    <span class="comment">//特别注意，check每一次递归时，check都for ( int i = 0 ; i &lt; max ; i++ ) &#123; ，不断回溯，把第一个第一列所有情况弄完后，进行第一行第二列在不断check在回溯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span> <span class="params">( <span class="type">int</span> n )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == max ) &#123;  <span class="comment">//n=8表示8个皇后就已经放好了</span></span><br><span class="line">            print ();</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; max ; i++ ) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后，放到该行的第一个</span></span><br><span class="line">            array[ n ] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> ( judge ( n ) )&#123;</span><br><span class="line">                <span class="comment">//接着放n+1个皇后</span></span><br><span class="line">                check ( n+<span class="number">1</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突就继续执行array[n]=i;即将该皇后移动到本行下一列</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第n个皇后，就就去检测，该皇后与已经拜放的皇后是否冲突</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 位置是否符合规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span> <span class="params">( <span class="type">int</span> n )</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明</span></span><br><span class="line">            <span class="comment">//1.array[ i ] == array[ n ] 表示判断第n个皇后和前面的n-1个皇后是否在同一列，</span></span><br><span class="line">            <span class="comment">//2.Math.abs ( n - i ) == Math.abs ( array[ n ] - array[ i ] )  表示判断第n个皇后和前面的n-1个皇后是否在同一斜线</span></span><br><span class="line">            <span class="comment">//3.因为我们的下标表示行-1所以下标不断递增所以不用判断是否在同一行</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//因为我们之前规定，一维数组下标表示行-1，下标对应的值表示在该行上第几列，</span></span><br><span class="line">            <span class="comment">//举例1.第一行第一个为皇后1 arr[0]=0  第二个皇后第二行第二列arr[1]=1</span></span><br><span class="line">            <span class="comment">//Math.abs ( 1 - 0 ) == Math.abs ( array[ 1 ] - array[ 0 ] )=1</span></span><br><span class="line">            <span class="comment">//第三行第二列arr[2]=1   第6行第5列arr[5]=4</span></span><br><span class="line">            <span class="comment">//Math.abs ( 5 - 2 ) == Math.abs ( array[ 5 ] - array[ 2 ] )=3</span></span><br><span class="line">            <span class="comment">//此时画图他们确实为一条斜线</span></span><br><span class="line">            <span class="keyword">if</span> ( array[ i ] == array[ n ] || Math.abs ( n - i ) == Math.abs ( array[ n ] - array[ i ] ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将皇后拜访的位置打印出来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; array.length ; i++ ) &#123;</span><br><span class="line">            System.out.print ( array[ i ] + <span class="string">&quot; &quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println ( );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>DoubleLinkList</title>
    <url>/posts/b0ed8996.html</url>
    <content><![CDATA[<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script><br><span class="p center logo large">双链表</span><br><span class="p center small">数据结构——学习双链表</span></p>
<blockquote>
<p>单项链表与双向链表对比</p>
<blockquote>
<p>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找</p>
<p>单项链表不能自我删除，需要靠辅助节点，找到一个temp，temp是待删除节点的前一个节点。双向链表，则可以自我删除。<br><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230113224105760.png" alt="image (1)" style="zoom:67%;"></p>
</div></div></p>
</blockquote>
</blockquote>
<p><em>相对于单项链表,双向链表增加了pre,来指向前一个节点,从而达到双向</em></p>
<hr>
<h3 id="增删改查分析"><a href="#增删改查分析" class="headerlink" title="增删改查分析"></a>增删改查分析</h3><p>分析 :双向链表的遍历,增加,删除,修改的操作思路</p>
<ul>
<li><strong>遍历</strong> :和单链表一样,不光可以向前查找,也可以向后</li>
<li><p><strong>添加</strong> :(默认添加到链表最后)</p>
<ul>
<li><p>先找到双向链表的最后节点</p>
</li>
<li><p>temp.next=newHeroNode</p>
</li>
<li><p>newHeroNode.pre=temp</p>
</li>
</ul>
</li>
<li><strong>修改</strong> :的思路和原理与单链表一样(通过遍历找到节点的.no然后改data值)</li>
<li><strong>删除</strong><ul>
<li>因为是双向链表,因此可以自我删除,不需要找前后值</li>
<li>直接找到要删除的节点,比如temp</li>
<li>temp.pre.next=temp.next(例如删除5号节点,把2号的next指向9号)<div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230113230023680.png" alt="image (1)" style="zoom:67%;"></p>
</div></div>
</li>
</ul>
</li>
</ul>
<h3 id="先定义HeroNode"><a href="#先定义HeroNode" class="headerlink" title="先定义HeroNode"></a>先定义HeroNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个heroNode,每个HeroNode 对象是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;  <span class="comment">//指向后一个节点  默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;  <span class="comment">//指向前一个节点   默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode2</span> <span class="params">( <span class="type">int</span> no, String name, String nickname )</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no       = no;</span><br><span class="line">        <span class="built_in">this</span>.name     = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方便，我们重写toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增删改查代码实现"><a href="#增删改查代码实现" class="headerlink" title="增删改查代码实现"></a>增删改查代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个双向链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkList</span> &#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点,头节点不要动，不存放具体数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode2</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span> ( <span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 <span class="title function_">getHead</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历双向链表</span></span><br><span class="line">    <span class="comment">//显示链表遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( )</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表为空&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> ( temp == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点的信息</span></span><br><span class="line">            System.out.println ( temp );</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加只能添加到最后</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时，</span></span><br><span class="line"><span class="comment">//        1.找到链表最后一个节点</span></span><br><span class="line"><span class="comment">//        2.将最后这个节点的next指向新节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">( HeroNode2 heroNode )</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while时，temp就指向最后</span></span><br><span class="line">        <span class="comment">//形成一个双向链表</span></span><br><span class="line">        temp.next    = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加，按照编号顺序添加（与单链表差不多，只是要多考虑pre）</span></span><br><span class="line">    <span class="comment">//如果有这个排名提示添加失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addpro</span> <span class="params">( HeroNode2 heroNode )</span> &#123;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此仍需要辅助节点来帮助我们添加</span></span><br><span class="line"><span class="comment">//        因为单链表,因此我们找的temp是位于添加位置的前一个节点，否则添加不进去</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;<span class="comment">//说明temp已经在链表最后</span></span><br><span class="line">                flag2=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next.no &gt; heroNode.no ) &#123;<span class="comment">//位置找到，就在temp后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( temp.next.no == heroNode.no ) &#123;<span class="comment">//要添加的heronode存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//后移遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;<span class="comment">//编号存在</span></span><br><span class="line">            System.out.printf ( <span class="string">&quot;准备插入的英雄编号%d,已经存在,不能加入\n&quot;</span>, heroNode.no );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (  flag2 ) &#123;</span><br><span class="line">            heroNode.pre=temp;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入到正确位置。temp后面</span></span><br><span class="line">            <span class="type">HeroNode2</span> <span class="variable">next</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">            next.pre=heroNode;</span><br><span class="line">            heroNode.pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一个节点的内容</span></span><br><span class="line">    <span class="comment">//修改节点的信息，根据no来修改，name，nickname</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updata</span> <span class="params">( HeroNode2 newHeroNode )</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表为空&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据no编号</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//链表已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.no == newHeroNode.no ) &#123;</span><br><span class="line">                <span class="comment">//找到节点</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断节点是否可以找到</span></span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            temp.name     = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//没有找到</span></span><br><span class="line">            System.out.printf ( <span class="string">&quot;没有找到编号%d的节点，无法修改\n&quot;</span>, newHeroNode.no );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一个节点</span></span><br><span class="line">    <span class="comment">//对于双向链表，可以直接删除，只用找到自己本身即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span> <span class="params">( <span class="type">int</span> no )</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ( head.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;链表为空，无法删除&quot;</span> );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;  <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;  <span class="comment">//标志是否找到待删除节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;  <span class="comment">//到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.no == no ) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next != <span class="literal">null</span> ) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;  <span class="comment">//有条件，不能是最后一个，否则会出现空指针异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf ( <span class="string">&quot;列表中的no值无%d,无法删除\n&quot;</span>, no );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span> <span class="params">( <span class="type">int</span> no )</span> &#123;</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( temp.next == <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( temp.no == no ) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            System.out.println ( <span class="string">&quot;你查找的信息如下：&quot;</span> );</span><br><span class="line">            System.out.println ( temp );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf ( <span class="string">&quot;列表中的no值无%d,无法查到\n&quot;</span>, no );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        System.out.println ( <span class="string">&quot;双向链表的一个测试&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span> ( <span class="number">1</span>, <span class="string">&quot;松江&quot;</span>, <span class="string">&quot;及时雨&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span> ( <span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span> ( <span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span> );</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span> ( <span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个双向链表</span></span><br><span class="line">        <span class="type">DoubleLinkList</span> <span class="variable">doubleLinkList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkList</span> ( );</span><br><span class="line">        <span class="comment">/*//按照添加的顺序来添加</span></span><br><span class="line"><span class="comment">        doubleLinkList.add ( hero1 );</span></span><br><span class="line"><span class="comment">        doubleLinkList.add ( hero2 );</span></span><br><span class="line"><span class="comment">        doubleLinkList.add ( hero3 );</span></span><br><span class="line"><span class="comment">        doubleLinkList.add ( hero4 );</span></span><br><span class="line"><span class="comment">        //打印出来</span></span><br><span class="line"><span class="comment">        doubleLinkList.list ();*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照no值来添加</span></span><br><span class="line">        doubleLinkList.addpro ( hero1 );</span><br><span class="line">        doubleLinkList.addpro ( hero3 );</span><br><span class="line">        doubleLinkList.addpro ( hero2 );</span><br><span class="line">        doubleLinkList.addpro ( hero4 );</span><br><span class="line">        doubleLinkList.list ();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">newHeroNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span> ( <span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span> );</span><br><span class="line">        doubleLinkList.updata ( newHeroNode2 );</span><br><span class="line">        System.out.println (<span class="string">&quot;修改后&quot;</span> );</span><br><span class="line">        doubleLinkList.list ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        doubleLinkList.delete ( <span class="number">3</span> );</span><br><span class="line">        System.out.println (<span class="string">&quot;删除后的链表情况&quot;</span> );</span><br><span class="line">        doubleLinkList.list ( );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        doubleLinkList.find ( <span class="number">3</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
      </tags>
  </entry>
  <entry>
    <title>递归-迷宫</title>
    <url>/posts/5a67173c.html</url>
    <content><![CDATA[<span class="p center logo large">迷宫</span>
<span class="p center small">递归——应用</span>
<p><script type="text/javascript">
SAONotify('Update','欢迎光临！阳玥小屋上新啦！','location.reload(true);');
</script></p>
<h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><strong>小球找路径：</strong></p>
<p><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230126160647622.png" alt="image-20230126160647622" style="zoom:67%;"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Migong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="comment">//先创建一个二维数组，模拟迷宫</span></span><br><span class="line">        <span class="comment">//地图</span></span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">8</span> ][ <span class="number">7</span> ];</span><br><span class="line">        <span class="comment">//使用1表示墙</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">7</span> ; i++ ) &#123;</span><br><span class="line">            map[ <span class="number">0</span> ][ i ] = <span class="number">1</span>;</span><br><span class="line">            map[ <span class="number">7</span> ][ i ] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; <span class="number">7</span> ; i++ ) &#123;</span><br><span class="line">            map[ i ][ <span class="number">0</span> ] = <span class="number">1</span>;</span><br><span class="line">            map[ i ][ <span class="number">6</span> ] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[ <span class="number">3</span> ][ <span class="number">1</span> ] = <span class="number">1</span>;</span><br><span class="line">        map[ <span class="number">3</span> ][ <span class="number">2</span> ] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历出来</span></span><br><span class="line">        list ( map );</span><br><span class="line">        <span class="comment">//使用递归函数找路</span></span><br><span class="line">        <span class="comment">//setWay ( map, 1, 1 );</span></span><br><span class="line">        list ( map );</span><br><span class="line">        setWay2 ( map, <span class="number">1</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出新的地图，小球走过，并标识过的地图</span></span><br><span class="line">        list ( map );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">list</span> <span class="params">( <span class="type">int</span>[][] map )</span> &#123;</span><br><span class="line">        System.out.println (<span class="string">&quot;地图情况&quot;</span> );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">8</span> ;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; <span class="number">7</span> ; j++ ) &#123;</span><br><span class="line">                System.out.print ( map[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println ( );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//i,j表示从地图的哪个位置开始出发（1，1）</span></span><br><span class="line">    <span class="comment">//如果小球能到map[6][5]位置，则说明通路找到</span></span><br><span class="line">    <span class="comment">//约定：当map[i][j]为0表示该点没有走过，当为1表示墙，当为2表示通路可以走，3表示该点已经走过，但走不通</span></span><br><span class="line">    <span class="comment">//在走迷宫时，我们需要确定一个策略，下-》右-》上-》左如果该点走不通，在回溯</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 从哪个位置开始出发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  如果找到返回true,否在false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span> <span class="params">( <span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( map[ <span class="number">5</span> ][ <span class="number">5</span> ] == <span class="number">2</span> ) &#123;<span class="comment">//表示通路已经找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( map[ i ][ j ] == <span class="number">0</span> ) &#123;<span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line">                <span class="comment">//按策略下-》右-》上-》左</span></span><br><span class="line">                map[ i ][ j ] = <span class="number">2</span>; <span class="comment">//假设该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> ( setWay ( map, i+<span class="number">1</span>, j ) ) &#123;  <span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( setWay ( map, i, j + <span class="number">1</span> ) ) &#123;  <span class="comment">//向右走 </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (  setWay ( map, i-<span class="number">1</span>, j ) )&#123;  <span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( setWay ( map, i, j - <span class="number">1</span> ) ) &#123; <span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    map[ i ][ j ] = <span class="number">3</span>;  <span class="comment">//说明该节点走不通，是死路</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;  <span class="comment">//如果map[i][j]！=0，可能是1，2，3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改策略，上-》右下左</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay2</span> <span class="params">( <span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( map[ <span class="number">5</span> ][ <span class="number">5</span> ] == <span class="number">2</span> ) &#123;<span class="comment">//表示通路已经找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( map[ i ][ j ] == <span class="number">0</span> ) &#123;<span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line">                <span class="comment">//按策略下-》右-》上-》左</span></span><br><span class="line">                map[ i ][ j ] = <span class="number">2</span>; <span class="comment">//假设该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span> ( setWay2 ( map, i-<span class="number">1</span>, j ) ) &#123;  <span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( setWay2 ( map, i, j + <span class="number">1</span> ) ) &#123;  <span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (  setWay2 ( map, i+<span class="number">1</span>, j ) )&#123;  <span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( setWay2 ( map, i, j - <span class="number">1</span> ) ) &#123; <span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    map[ i ][ j ] = <span class="number">3</span>;  <span class="comment">//说明该节点走不通，是死路</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;  <span class="comment">//如果map[i][j]！=0，可能是1，2，3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><code>策略：下-》右-》上-》左</code><br><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230127221950295.png" alt="image-20230127221950295" style="zoom: 80%;"> </p>
</div></div></p>
<p><code>策略：上-》右-》下-》左</code><br><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览
    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://cdn.staticaly.com/gh/FloatingDream1001/markdown_blog@main/2023/1/image-20230127222120850.png" alt="image-20230127222120850" style="zoom:80%;"></p>
</div></div> </p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ol>
<li><p>小球得到的路径，和程序员设置的找路策略有关</p>
</li>
<li><p>所以目前求最短路径可以根据策略来找最短路径，改变策略顺序依次求出每个策略所得出的路径，进而比较求出最短路径。</p>
</li>
</ol>

<style></style>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Recursion</tag>
      </tags>
  </entry>
</search>
